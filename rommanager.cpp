// RomManager.cpp: implementation of the CRomManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RomManager.h"
#include <math.h>
#include ".\\usb\\patch.h"
#include "out.h"
#include "arm9_aac.inc"
#include "arm9_47c.inc"
#include "arm9_550.inc"
#include "arm7_erase_ez3.inc"
#include "arm7_readrom512_ez3.inc"
#include "arm7_readsaver_ez3.inc"
#include "arm7_verify_ez3.inc"
#include "arm7_writesaver_ez3.inc"
#include "arm9_thumb.inc"
#include "arm9_47c_thumb.inc"
	#include "arm9_readcard2.inc"
	#include "arm9_thumb_readcard2.inc"	

	#include "arm7_thumb_verify_ez3.inc"
	#include "arm7_thumb_erase_ez3.inc"
	#include "arm7_thumb_readsaver_ez3.inc"
	#include "arm7_thumb_writesaver_ez3.inc" 


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRomManager::CRomManager()
{
	for(int i =0;i<64;i++)
	{
		m_flagNES_CPUHackDisable[i] = 0 ;
		m_flagNES_FFUHackEnable[i] = 0 ;
		m_flagNES_UsePALTimeing[i] = 0 ;
		m_flagNES_FollowMem[i] = 0 ;
		m_dwNES_FollowSprite[i] = 0 ;

		m_flagPCE_50CPUClock[i] = 0;//	
		m_flagPCE_USRom[i] = 0 ; //bit1	
		m_flagPCE_CPUHackDisable[i] = 0;	
		m_flagPCE_FollowMem[i] = 0 ;		
		m_dwPCE_FollowSprite[i] = 0 ;	
	}
}

CRomManager::~CRomManager()
{

}
/*
void CRomManager::TrimRom(BYTE **pBuf, int *iSize)
{
	int  addr,i;
	bool OverDump;

	if(*iSize > 0x8000)
	{
		if((*iSize % 0x8000) != 0)
			addr = *iSize - (*iSize % 0x8000);
		else
			addr = *iSize - 0x8000;

		while(addr > 0x8000)
		{
			OverDump = false;
			for(i=addr; i<*iSize; i++) 
				if(((*pBuf)[i] != 0x00)&&((*pBuf)[i] != 0xFF))
					break;
			if(i == *iSize)
			{
				OverDump = true;
			}

			if(!OverDump)
			{
				break;
			}
			*iSize = addr;
			addr -= 0x8000;
		}
	}
}
*/
DWORD CRomManager::EnumGBC2GBAFromFiles(BYTE *pBuf, DWORD *pSize ,LPCTSTR pFile1,...)
{
	CFile fiGbc ;
	DWORD result , totalsize = 0 , size = 0 ;
	if(pSize == 0)
		return -1;

	//if(pBuf == NULL)
	va_list filelist ;
	va_start(filelist,pFile1);
	//打开第一个文件
	result = fiGbc.Open(pFile1,CFile::modeRead);
	if(result == 0)
	{
		va_end(filelist);
		return -2 ;
	}
	totalsize += fiGbc.GetLength();
	fiGbc.Close();
	while(pFile1)
	{
		pFile1 = va_arg(filelist,LPCTSTR);
		if(pFile1)
		{
			result = fiGbc.Open(pFile1,CFile::modeRead);
			if(result == 0)
			{
				va_end(filelist);
				return -2 ;
			}
			totalsize += fiGbc.GetLength();
			fiGbc.Close();
		}
	}  
	va_end(filelist);
//now here count the size of the totoal
	if(*pSize<totalsize) //小于，需要重新调用文件
	{
		*pSize = totalsize ;
		return -3 ;
	}
	*pSize = totalsize ;
	if(pBuf == NULL)
		return -4 ;
//大于或者等于，那么可以拷贝
	totalsize = 0 ;
	va_start(filelist,pFile1);
	//打开第一个文件
	result = fiGbc.Open(pFile1,CFile::modeRead);
	totalsize += (size = fiGbc.GetLength());
	fiGbc.Read(pBuf,size);
	fiGbc.Close();
	while(pFile1)
	{
		pFile1 = va_arg(filelist,LPCTSTR);
		if(pFile1)
		{
			result = fiGbc.Open(pFile1,CFile::modeRead);
			size = fiGbc.GetLength();
			fiGbc.Read(pBuf+totalsize,size);
			totalsize += size ;
			fiGbc.Close();
		}
	}
	va_end(filelist);

	return 0;
}

DWORD CRomManager::EnumGBC2GBAFromFiles(BYTE *pBuf, DWORD *pSize , CStringArray &fileArray)
{
	CFile fiGbc ;
	CString strFile1 ;
	int filelist ;
	DWORD result , totalsize = 0 , size = 0 ;
	if(pSize == 0)
		return -1;
	filelist = fileArray.GetSize();
	if(filelist<2)
		return -6 ;

	//打开第一个文件
	strFile1 = fileArray.GetAt(0);
	result = fiGbc.Open(strFile1,CFile::modeRead);
	if(result == 0)
	{
		return -2 ;
	}
	totalsize += fiGbc.GetLength();
	fiGbc.Close();
	for(int i=1;i<filelist;i++)
	{
		strFile1 = fileArray.GetAt(i);
		result = fiGbc.Open(strFile1,CFile::modeRead);
		if(result == 0)
		{
			return -2 ;
		}
		totalsize += fiGbc.GetLength();
		fiGbc.Close();
	}
//now here count the size of the totoal
	if(*pSize<totalsize) //小于，需要重新调用文件
	{	
		*pSize = totalsize ;
		return -3 ;
	}
	*pSize = totalsize ;
	if(pBuf == NULL)
		return -4 ;
//大于或者等于，那么可以拷贝
	totalsize = 0 ;
	//打开第一个文件
	strFile1 = fileArray.GetAt(0);
	result = fiGbc.Open(strFile1,CFile::modeRead);
	totalsize += (size = fiGbc.GetLength());
	fiGbc.Read(pBuf,size);
	fiGbc.Close();
	for(i=1;i<filelist;i++)
	{
		strFile1 = fileArray.GetAt(i);
		result = fiGbc.Open(strFile1,CFile::modeRead);
		size = fiGbc.GetLength();
		fiGbc.Read(pBuf+totalsize,size);
		totalsize += size ;
		fiGbc.Close();
	}
	return 0;
}

DWORD CRomManager::EnumNES2GBAFromFiles(BYTE *pBuf, DWORD *pSize, LPCTSTR pFile1, ...)
{
	CFile fiGbc ;
	DWORD result , totalsize = 0 , size = 0 , index = 0;
	if(pSize == 0)
		return -1;

	//if(pBuf == NULL)
	va_list filelist ;
	va_start(filelist,pFile1);
	//打开第一个文件,即模拟器文件
	result = fiGbc.Open(pFile1,CFile::modeRead);
	if(result == 0)
	{
		va_end(filelist);
		return -2 ;
	}
	totalsize += fiGbc.GetLength();
	fiGbc.Close();
	while(pFile1)
	{
		pFile1 = va_arg(filelist,LPCTSTR);
		if(pFile1)
		{
			result = fiGbc.Open(pFile1,CFile::modeRead);
			if(result == 0)
			{
				va_end(filelist);
				return -2 ;
			}
			totalsize += fiGbc.GetLength();
			totalsize += 48 ;
			fiGbc.Close();
		}
	}
	va_end(filelist);
//now here count the size of the totoal
	if(*pSize<totalsize) //小于，需要重新调用文件
	{
		*pSize = totalsize ;
		return -3 ;
	}
	*pSize = totalsize ;
	if(pBuf == NULL)
		return -4 ;
//大于或者等于，那么可以拷贝
	totalsize = 0 ;
	va_start(filelist,pFile1);
	//打开第一个文件
	result = fiGbc.Open(pFile1,CFile::modeRead);
	totalsize += (size = fiGbc.GetLength());
	fiGbc.Read(pBuf,size);
	fiGbc.Close();
	while(pFile1)
	{
		pFile1 = va_arg(filelist,LPCTSTR);
		if(pFile1)
		{
			result = fiGbc.Open(pFile1,CFile::modeRead);
			totalsize += 48 ;
			size = fiGbc.GetLength();
			//产生所需要的内存块
			FormatNESPreload(index,size,fiGbc.GetFileTitle());
			memcpy(pBuf+totalsize-48,m_bufPreload,48);
			fiGbc.Read(pBuf+totalsize,size);
			totalsize += size ;
			fiGbc.Close();
			index++ ;
		}
	}
	va_end(filelist);

	return 0;

}

DWORD CRomManager::EnumNES2GBAFromFiles(BYTE *pBuf, DWORD *pSize, CStringArray &fileArray)
{
	CString strFile1 ;
	int filelist ;
	CFile fiGbc ;
	DWORD result , totalsize = 0 , size = 0 , index = 0;
	if(pSize == 0)
		return -1;

	filelist = fileArray.GetSize();
	if(filelist<2)
		return -6 ;
	//打开第一个文件,即模拟器文件
	strFile1=fileArray.GetAt(0);
	result = fiGbc.Open(strFile1,CFile::modeRead);
	if(result == 0)
	{
		return -2 ;
	}
	totalsize += fiGbc.GetLength();
	fiGbc.Close();
	for(int i=1;i<filelist;i++)
	{
		strFile1 = fileArray.GetAt(i);
		result = fiGbc.Open(strFile1,CFile::modeRead);
		if(result == 0)
		{
			return -2 ;
		}
		totalsize += fiGbc.GetLength();
		totalsize += 48 ;
		fiGbc.Close();
	}
//now here count the size of the totoal
	if(*pSize<totalsize) //小于，需要重新调用文件
	{
		*pSize = totalsize ;
		return -3 ;
	}
	*pSize = totalsize ;
	if(pBuf == NULL)
		return -4 ;
//大于或者等于，那么可以拷贝
	totalsize = 0 ;
	//打开第一个文件
	strFile1=fileArray.GetAt(0);
	result = fiGbc.Open(strFile1,CFile::modeRead);
	totalsize += (size = fiGbc.GetLength());
	fiGbc.Read(pBuf,size);
	fiGbc.Close();
	for(i=1;i<filelist;i++)
	{
		strFile1 = fileArray.GetAt(i);
		result = fiGbc.Open(strFile1,CFile::modeRead);
		size = fiGbc.GetLength();
		FormatNESPreload(index,size,fiGbc.GetFileTitle());
		memcpy(pBuf+totalsize,m_bufPreload,48);
		totalsize += 48 ;
		fiGbc.Read(pBuf+totalsize,size);
		totalsize += size ;
		fiGbc.Close();
		index++ ;
	}
	return 0;

}

void CRomManager::SetNESCharacter(int iIndex ,
								  BOOL fFFUhackEn,
								  BOOL fCPUhackDis,
								  BOOL fUsePALTimeing,
								  BOOL fFollowMem,
								  DWORD dwFollowSprite)
{
	m_flagNES_CPUHackDisable[iIndex] = fCPUhackDis ;
	m_flagNES_FFUHackEnable[iIndex] = fFFUhackEn ;
	m_flagNES_UsePALTimeing[iIndex] = fUsePALTimeing ;
	m_flagNES_FollowMem[iIndex] = fFollowMem ;
	m_dwNES_FollowSprite[iIndex] = dwFollowSprite ;
}

void	CRomManager::FormatNESPreload(int iIndex, DWORD length , LPCTSTR name) 
{
	memset(m_bufPreload,0,64);
	int len = strlen(name);
	memcpy(m_bufPreload,name,len<32?len:32);
	*((DWORD*)(m_bufPreload+32)) = length ;
	if(m_flagNES_FFUHackEnable[iIndex])
		*(m_bufPreload+36) |= 0x1 ;
	if(m_flagNES_CPUHackDisable[iIndex])
		*(m_bufPreload+36) |= 0x2 ;
	if(m_flagNES_UsePALTimeing[iIndex])
		*(m_bufPreload+36) |= 0x4 ;
	if(m_flagNES_FollowMem[iIndex])
		*(m_bufPreload+36) |= 0x20 ;
	*((DWORD*)(m_bufPreload+40)) = m_dwNES_FollowSprite[iIndex] ;
}

void CRomManager::SetPCECharacter(int iIndex ,
								  BOOL fCPU50Clock,
								  BOOL fUSRom,
								  BOOL fCPUhackDis,
								  BOOL fFollowMem,
								  DWORD dwFollowSprite)
{
	m_flagPCE_50CPUClock[iIndex] = fCPU50Clock ;
	m_flagPCE_USRom[iIndex] = fUSRom ;
	m_flagPCE_CPUHackDisable[iIndex] = fCPUhackDis ;
	m_flagPCE_FollowMem[iIndex] = fFollowMem ;
	m_dwPCE_FollowSprite[iIndex] = dwFollowSprite ;
}

void	CRomManager::FormatPCEPreload(int iIndex, DWORD length , LPCTSTR name) 
{
	char pce[5]={0x4e,0x45,0x53,0x1A,0x40};
	memset(m_bufPreload,0,64);
	int len = strlen(name);
	memcpy(m_bufPreload,name,len<32?len:32);
	*((DWORD*)(m_bufPreload+32)) = length + 0x10;
	if(m_flagPCE_50CPUClock[iIndex])
		*(m_bufPreload+36) |= 0x1 ;
	if(m_flagPCE_USRom[iIndex])
		*(m_bufPreload+36) |= 0x2 ;
	if(m_flagPCE_CPUHackDisable[iIndex])
		*(m_bufPreload+36) |= 0x4 ;
	if(m_flagPCE_FollowMem[iIndex])
		*(m_bufPreload+36) |= 0x20 ;
	*((DWORD*)(m_bufPreload+40)) = m_dwPCE_FollowSprite[iIndex] ;
	memset(m_bufPreload+48,0x20,16);
	memcpy(m_bufPreload+48,pce,5);
}

DWORD CRomManager::EnumPCE2GBAFromFiles(BYTE *pBuf, DWORD *pSize ,LPCTSTR pFile1,...)
{
	int i = -1 ;
	CFile fiGbc ;
	DWORD result , totalsize = 0 , size = 0 , index = 0;
	BYTE *pTmp = NULL ;
	if(pSize == 0)
		return -1;

	//if(pBuf == NULL)
	va_list filelist ;
	va_start(filelist,pFile1);
	//打开第一个文件,即模拟器文件
	result = fiGbc.Open(pFile1,CFile::modeRead);
	if(result == 0)
	{
		va_end(filelist);
		return -2 ;
	}
	totalsize += fiGbc.GetLength();
	fiGbc.Close();
	while(pFile1)
	{
		pFile1 = va_arg(filelist,LPCTSTR);
		if(pFile1)
		{
			result = fiGbc.Open(pFile1,CFile::modeRead);
			if(result == 0)
			{
				va_end(filelist);
				return -2 ;
			}
			totalsize += fiGbc.GetLength();
			totalsize += 64 ;
			fiGbc.Close();
		}
	}
	va_end(filelist);
//now here count the size of the totoal
	*pSize = totalsize ;
	if(*pSize<totalsize) //小于，需要重新调用文件
		return -3 ;
	if(pBuf == NULL)
		return -4 ;
//大于或者等于，那么可以拷贝
	totalsize = 0 ;
	va_start(filelist,pFile1);
	//打开第一个文件
	result = fiGbc.Open(pFile1,CFile::modeRead);
	totalsize += (size = fiGbc.GetLength());
	fiGbc.Read(pBuf,size);
	fiGbc.Close();
	while(pFile1)
	{
		pFile1 = va_arg(filelist,LPCTSTR);
		if(pFile1)
		{
			result = fiGbc.Open(pFile1,CFile::modeRead);
			totalsize += 64 ;
			size = fiGbc.GetLength();
			if(pTmp==NULL)
				pTmp = new BYTE[size] ;
			fiGbc.Read(pTmp,size);
			if(*(WORD*)(pTmp+0xE) == 0x3156)
			{
				for(i=0x10;i<0x200;i++)
				{
					if(pTmp[i]!=0)
						break;
				}
			}
			if(i == 0x200)
			{
				size -= 0x200 ;
				memcpy(pBuf+totalsize,&(pTmp[0x200]),size);
			}
			else
			{
				memcpy(pBuf+totalsize,pTmp,size);
			}
			//产生所需要的内存块
			FormatPCEPreload(index,size,fiGbc.GetFileTitle());
			memcpy(pBuf+totalsize-64,m_bufPreload,64);
			totalsize += size ;
			fiGbc.Close();
			if(pTmp)
			{
				delete pTmp ; pTmp = NULL;
			}
			index++ ;
		}
	}
	va_end(filelist);
	return 0 ;
}

DWORD CRomManager::EnumPCE2GBAFromFiles(BYTE *pBuf, DWORD *pSize ,CStringArray &fileArray)
{
	int i = -1 ;
	CFile fiGbc ;
	CString strFile1 ;
	int filelist ;
	DWORD result , totalsize = 0 , size = 0 , index = 0;
	BYTE *pTmp = NULL ;
	if(pSize == 0)
		return -1;
	filelist = fileArray.GetSize();
	if(filelist<2)
		return -6 ;

	//打开第一个文件
	strFile1 = fileArray.GetAt(0);
	result = fiGbc.Open(strFile1,CFile::modeRead);
	if(result == 0)
	{
		return -2 ;
	}
	totalsize += fiGbc.GetLength();
	fiGbc.Close();
	for(int j=1;j<filelist;j++)
	{
		strFile1 = fileArray.GetAt(j);
		result = fiGbc.Open(strFile1,CFile::modeRead);
		if(result == 0)
		{
			return -2 ;
		}
		totalsize += fiGbc.GetLength();
		totalsize += 64 ;
		fiGbc.Close();
	}
//now here count the size of the totoal
	if(*pSize<totalsize) //小于，需要重新调用文件
	{
		*pSize = totalsize ;
		return -3 ;
	}
	*pSize = totalsize ;
	if(pBuf == NULL)
		return -4 ;
//大于或者等于，那么可以拷贝
	totalsize = 0 ;
	//打开第一个文件
	strFile1=fileArray.GetAt(0);
	result = fiGbc.Open(strFile1,CFile::modeRead);
	totalsize += (size = fiGbc.GetLength());
	fiGbc.Read(pBuf,size);
	fiGbc.Close();
	for(j=1;j<filelist;j++)
	{
		strFile1 = fileArray.GetAt(j);
		result = fiGbc.Open(strFile1,CFile::modeRead);
		size = fiGbc.GetLength();
		totalsize += 64 ;
		size = fiGbc.GetLength();
		if(pTmp==NULL)
			pTmp = new BYTE[size] ;
		fiGbc.Read(pTmp,size);
		if(*(WORD*)(pTmp+0xE) == 0x3156)
		{
			for(i=0x10;i<0x200;i++)
			{
				if(pTmp[i]!=0)
					break;
			}
		}
		if(i == 0x200)
		{
			size -= 0x200 ;
			memcpy(pBuf+totalsize,&(pTmp[0x200]),size);
		}
		else
		{
			memcpy(pBuf+totalsize,pTmp,size);
		}
		//产生所需要的内存块
		FormatPCEPreload(index,size,fiGbc.GetFileTitle());
		memcpy(pBuf+totalsize-64,m_bufPreload,64);
		totalsize += size ;
		fiGbc.Close();
		if(pTmp)
		{
			delete pTmp ; pTmp = NULL;
		}
		index++ ;
	}
	return 0 ;
}

DWORD CRomManager::AddROMBomaPatch(LPCTSTR Boma, LPCTSTR ROM,BYTE whattodo)
{
	DWORD result = 0;
	CFile file ;
	PROCESS_INFORMATION pcInfo ;
	STARTUPINFO			startInfo ;
	BOOL fSuc = NULL ;
	CString strPath = Boma ;
	CString CommandLine ;

	if((Boma==NULL)||(ROM==NULL))
		return -1;
	//检查是否所需文件都传递正确
	result = file.Open(Boma,CFile::modeRead);
	if(result == 0)
	{
		result = GetLastError();
		return -2 ;
	}
	file.Close();
	result = file.Open(ROM,CFile::modeRead);
	if(result == 0)
	{
		return -2 ;
	}
	file.Close();
	strPath = strPath.Left(strPath.ReverseFind('\\'));

	switch(whattodo)
	{
	case 'u':
	case 'U':
		CommandLine = "\"" ;
		CommandLine += Boma ;
		CommandLine += "\"" ;
		CommandLine +=" -u " ;
		CommandLine += "\"" ;
		CommandLine	+= ROM ;
		CommandLine += "\"" ;
		break;
	case 'f':
	case 'F':
		CommandLine = "\"" ;
		CommandLine += Boma ;
		CommandLine += "\"" ;
		CommandLine +=" -f " ;
		CommandLine += "\"" ;
		CommandLine	+= ROM ;
		CommandLine += "\"" ;
		break;
	case 'i':
	case 'I':
		CommandLine = "\"" ;
		CommandLine += Boma ;
		CommandLine += "\"" ;
		CommandLine +=" -i " ;
		CommandLine += "\"" ;
		CommandLine	+= ROM ;
		CommandLine += "\"" ;
		break;
	case 'a':
	case 'A':
		CommandLine = "\"" ;
		CommandLine += Boma ;
		CommandLine += "\"" ;
		CommandLine +=" -a " ;
		CommandLine += "\"" ;
		CommandLine	+= ROM ;
		CommandLine += "\"" ;
		break;
	case 'r':
	case 'R':
		CommandLine = "\"" ;
		CommandLine += Boma ;
		CommandLine += "\"" ;
		CommandLine +=" -r " ;
		CommandLine += "\"" ;
		CommandLine	+= ROM ;
		CommandLine += "\"" ;
		break;
	case 'm':
	case 'M':
		CommandLine = "\"" ;
		CommandLine += Boma ;
		CommandLine += "\"" ;
		CommandLine +=" -m " ;
		CommandLine += "\"" ;
		CommandLine	+= ROM ;
		CommandLine += "\"" ;
		break;
	default:
		CommandLine = "\"" ;
		CommandLine += Boma ;
		CommandLine += "\"" ;
		CommandLine +=" " ;
		CommandLine += "\"" ;
		CommandLine	+= ROM ;
		CommandLine += "\"" ;

	}
	memset(&pcInfo,0,sizeof(pcInfo));
	memset(&startInfo,0,sizeof(startInfo));
	startInfo.cb = sizeof(startInfo);
	startInfo.dwFlags =STARTF_USESHOWWINDOW;
	startInfo.wShowWindow = SW_SHOW ;
	fSuc = CreateProcess(NULL,CommandLine.GetBuffer(CommandLine.GetLength()),NULL,NULL,FALSE,
						CREATE_NEW_CONSOLE|CREATE_SUSPENDED,
						NULL,
						strPath,//NULL,
						&startInfo,&pcInfo);
	CommandLine.ReleaseBuffer(-1);
	if(fSuc)
	{
		ResumeThread(pcInfo.hThread);
		//等待线呈结束
		WaitForSingleObject(pcInfo.hThread,INFINITE);
		GetExitCodeProcess(pcInfo.hProcess,&result);
		return result;
	}
	else
		return 0x55aaaa55 ;

}

DWORD CRomManager::ApplyIPSPatch(LPCTSTR ips , LPCTSTR ROM)
{
	DWORD result = 0 , ipsLen = 0 , offset = 0 , position = 0 , replLen = 0 ;
	CFile file ;
	BYTE *pBuf = NULL ;

	if((ips==NULL)||(ROM==NULL))
		return -1;
	//检查是否所需文件都传递正确
	result = file.Open(ips,CFile::modeRead);
	if(result == 0)
	{//找不到文件,失败
		return -2 ;
	}
	ipsLen = file.GetLength();
	//读出ips补丁
	pBuf = new BYTE[ipsLen] ;
	file.Read(pBuf,ipsLen);
	file.Close();
	result = file.Open(ROM,CFile::modeRead|CFile::modeWrite);
	if(result == 0)
	{//找不到文件,失败
		if(pBuf)
			delete pBuf ;
		pBuf = NULL ;
		return -2 ;
	}
	if(
		(pBuf[0] != 'P') ||
		(pBuf[1] != 'A') ||
		(pBuf[2] != 'T') ||
		(pBuf[3] != 'C') ||
		(pBuf[4] != 'H')
		) 
	{//ips文件格式不正确,返回失败
		if(pBuf)
			delete pBuf ;
		pBuf = NULL ;
		file.Close();
		return -3 ;
	}
	offset = 5 ;
	while(!((pBuf[offset]==0x45)&&(pBuf[offset+1]==0x4f)&&(pBuf[offset+2]==0x46)))
	{
		position = (pBuf[offset]<<16) + (pBuf[offset+1]<<8) + (pBuf[offset+2]);
		offset += 3 ;
		replLen = (pBuf[offset]<<8) + (pBuf[offset+1]) ;
		offset += 2 ;
		file.Seek(position,CFile::begin);
		if(replLen)
			file.Write(&(pBuf[offset]),replLen);
		offset += replLen ;
	}
	file.Close();
	if(pBuf) delete []pBuf ; pBuf = NULL ;
	return 0 ;
}

DWORD CRomManager::ApplyIPSPatch(LPCTSTR ips,BYTE* pROM,DWORD RomLen)
{
	DWORD result = 0 , ipsLen = 0 , offset = 0 , position = 0 , replLen = 0 ;
	CFile file ;
	BYTE *pBuf = NULL ;

	if((ips==NULL)||(pROM==NULL))
		return -1;
	//检查是否所需文件都传递正确
	result = file.Open(ips,CFile::modeRead);
	if(result == 0)
	{//找不到文件,失败
		return -2 ;
	}
	ipsLen = file.GetLength();
	//读出ips补丁
	pBuf = new BYTE[ipsLen] ;
	file.Read(pBuf,ipsLen);
	file.Close();

	if(
		(pBuf[0] != 'P') ||
		(pBuf[1] != 'A') ||
		(pBuf[2] != 'T') ||
		(pBuf[3] != 'C') ||
		(pBuf[4] != 'H')
		) 
	{//ips文件格式不正确,返回失败
		if(pBuf)
			delete pBuf ;
		pBuf = NULL ;
		return -3 ;
	}
	offset = 5 ;
	while(offset+1<ipsLen)
	{
		position = (pBuf[offset]<<16) + (pBuf[offset+1]<<8) + (pBuf[offset+2]);
		offset += 3 ;
		replLen = (pBuf[offset]<<8) + (pBuf[offset+1]) ;
		offset += 2 ;
		if((position+replLen)>=RomLen)
		{
			if(pBuf) delete []pBuf ; pBuf = NULL ;
			return -4 ;
		}
		memcpy(&(pROM[position]),&(pBuf[offset]),replLen) ;
		offset += replLen ;
	}
	if(pBuf) delete []pBuf ; pBuf = NULL ;
	return 0 ;
}

BYTE * CRomManager::FindMotif(BYTE *Buffer, DWORD BufferSize, BYTE *Motif, DWORD MotifSize)
{
	//Arithmatic from Dadycool
	BYTE* find = Buffer;
	while(find)
	{
		find = (BYTE *)memchr(Buffer,Motif[0],BufferSize-MotifSize);
		if (find)
		{
			if (memcmp(find,Motif,MotifSize) == 0)
			{
				break;
			}
		}
		BufferSize -= find - Buffer + 1;
		Buffer = find + 1;
	}
	return find;
}


BYTE* CRomManager::FindMotif(BYTE *Buffer, DWORD BufferSize, BYTE *Motif, DWORD MotifSize,DWORD skip1)
{
	//Arithmatic from Dadycool
	BYTE* find = Buffer;
	while(find)
	{
		find = (BYTE *)memchr(Buffer,Motif[0],BufferSize-MotifSize);
		if (find)
		{
			if ((memcmp(find,Motif,skip1) == 0)&&(memcmp(find+skip1+3,Motif+skip1+3,MotifSize-skip1-3)==0))
			{
				break;
			}
		}
		BufferSize -= find - Buffer + 1;
		Buffer = find + 1;
	}
	return find;
}



const unsigned short crc16tab[] =
{
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

WORD CRomManager::CRC16(unsigned char *ptr,unsigned int len)
{
	unsigned short crc16 = 0xFFFF;
	for (int i=0; i<len; i++)
	{
		unsigned char data = *(ptr + i);
		crc16 = (crc16 >> 8) ^ crc16tab[(crc16 ^ data) & 0xFF];
	}
	return crc16;
}

void CRomManager::ModifyNDSHeader(BYTE * pdata ,DWORD newArm9size,DWORD addon)
{
	//首先变动arm9size
	*(DWORD*)(pdata+0x2c) = newArm9size ;
	//arm7开始地址
	*(DWORD*)(pdata+0x30) = *(DWORD*)(pdata+0x30) + addon ;
	//Filename table offset (ROM)
	*(DWORD*)(pdata+0x40) =  *(DWORD*)(pdata+0x40) + addon;
	//FAT offset (ROM)
	*(DWORD*)(pdata+0x48) =  *(DWORD*)(pdata+0x48) + addon;
//改变后需要改变所有的剩余的文件偏移位置
	DWORD i = 0 ;
	DWORD offset = *(DWORD*)(pdata+0x48) ;
	DWORD *pWord = (DWORD*)(pdata+offset) ;
	while((*(pWord+i)!=0xFFFFFFFF) && (*(pWord+i)!=0))
	{
		*(pWord+i) += addon ;
		i++ ;
	}
	//ARM9 overlay src (ROM)
	if(*(DWORD*)(pdata+0x50))
		*(DWORD*)(pdata+0x50) = *(DWORD*)(pdata+0x50) + addon;
	//ARM7 overlay src (ROM)
	if(*(DWORD*)(pdata+0x58))
		*(DWORD*)(pdata+0x58) = *(DWORD*)(pdata+0x58) + addon;
	//Icon+titles (ROM)
	if(*(DWORD*)(pdata+0x68))
		*(DWORD*)(pdata+0x68) = *(DWORD*)(pdata+0x68) + addon;
	//secure crc16
	*(WORD*)(pdata+0x6C) = CRC16(pdata+0x4000,0x4000);
	
	//ROM size 
	*(DWORD*)(pdata+0x80) = *(DWORD*)(pdata+0x80) + addon;
	//header CRC16
	*(WORD*)(pdata+0x15E) = CRC16(pdata,0x15E);

}

void CRomManager::fixCRC(BYTE * pdata)
{
	//secure crc16
	*(WORD*)(pdata+0x6C) = CRC16(pdata+0x4000,0x4000);
	
	//header CRC16
	*(WORD*)(pdata+0x15E) = CRC16(pdata,0x15E);

}

BYTE CRomManager::GetSaverSpacial(BYTE * pdata)
{
	const BYTE kim_0341[] = "KIMMUNICATOR";
	if(!memcmp(pdata,kim_0341,12))
		return 1 ;
	const BYTE band_0036[] = {0x42 ,0x41 ,0x4E ,0x44 ,0x42 ,0x52 ,0x4F ,0x53 ,0x00 ,0x00 ,0x00 ,0x00};
	if(!memcmp(pdata,band_0036,12))
		return 1 ;
	const BYTE sherk_0141[] = {0x53 ,0x55 ,0x50 ,0x45 ,0x52 ,0x20 ,0x53 ,0x4C ,0x41 ,0x4D ,0x00 ,0x00};
	if(!memcmp(pdata,sherk_0141,12))
		return 2 ;
	const BYTE puyo_0072[] = {0x50 ,0x55 ,0x59 ,0x4F ,0x20 ,0x46 ,0x45 ,0x56 ,0x45 ,0x52 ,0x00 ,0x00};
	if(!memcmp(pdata,puyo_0072,12))
		return 1 ;

	const BYTE mariolui_0297[] = "MARIO&LUIGI2";
	if(!memcmp(pdata,mariolui_0297,12))
		return 1 ;

	return 0 ;
}


BOOL CRomManager::QuerySpecial(BYTE * pdata,DWORD &offset)
{
	offset = 0 ;
	const BYTE skybord_0176[] = "TH SK8LAND\0\0AH9P" ;
	if(!memcmp(pdata,skybord_0176,16))
	{
		offset = 0x200 ;
		return TRUE ;
	}
	const BYTE serial_0472[]="DS5THETRUMP\0";
	if(!memcmp(pdata,serial_0472,12))
	{
		offset = 0x200 ;
		return TRUE ;
	}

	const BYTE skybord_0174[] = "TH SK8LAND\0\0" ; //解决死机问题
	if(!memcmp(pdata,skybord_0174,12))
		return TRUE ;
	const BYTE animol_0389[] = "ANIMAL CROSS";
	if(!memcmp(pdata,animol_0389,12))
		return TRUE ;
	const BYTE an_j_0193[] = "DOUBUTU MORI" ;
	if(!memcmp(pdata,an_j_0193,12))
	{
		offset = 0x200 ;
		return TRUE ;
	}
	const BYTE burst_0352[] = {0x42 ,0x41 ,0x4D ,0x44 ,0x53 ,0x2D ,0x45 ,0x55 ,0x00 ,0x00 ,0x00 ,0x00};
	if(!memcmp(pdata,burst_0352,12))
		return TRUE ;

	const BYTE newmario_0434[] = {0x4E ,0x45 ,0x57 ,0x20 ,0x4D ,0x41 ,0x52 ,0x49 ,0x4F ,0x00 ,0x00 ,0x00};
	if(!memcmp(pdata,newmario_0434,12))
		return TRUE ;

	const BYTE harve_0561[] = "HM DS\0\0\0\0\0\0\0";
	if(!memcmp(pdata,harve_0561,12))
		return TRUE ;

	return FALSE ;

}

BOOL CRomManager::NDSPatch1(BYTE*  &pGame,DWORD &romsize,BYTE *bSavePatch,WORD rompage ,WORD rampage ,bool b_ids,bool b_gba)
{//replace file
#define SINGLECART 1
	#define BSAD_M 0x73c

	unsigned char compress2[] = 
	{
		0xF0 ,0x00 ,0x2D ,0xE9 ,0x06 ,0x00 ,0x10 ,0xE9 ,
		0x02 ,0x20 ,0x80 ,0xE0 ,0x21 ,0x3C ,0x40 ,0xE0 ,
		0xFF ,0x14 ,0xC1 ,0xE3 ,0x01 ,0x10 ,0x40 ,0xE0 ,
		0x02 ,0x40 ,0xA0 ,0xE1 ,0xFF ,0xFF ,0xFF ,0xEA ,
		0x01 ,0x00 ,0x53 ,0xE1 ,0x17 ,0x00 ,0x00 ,0xDA ,
		0x01 ,0x50 ,0x73 ,0xE5 ,0x08 ,0x60 ,0xA0 ,0xE3 ,
		0xFF ,0xFF ,0xFF ,0xEA ,0x01 ,0x60 ,0x56 ,0xE2 ,
		0xF8 ,0xFF ,0xFF ,0xBA ,0x80 ,0x00 ,0x15 ,0xE3
	};

	unsigned char arm9read[] = 
	{0xF0, 0x4F, 0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
	 0x00 ,0xA0 ,0xA0 ,0xE1 ,0xE0 ,0x90 ,0x9F ,0xE5 ,
	 0x20 ,0x70 ,0x8A ,0xE2 ,0xDC ,0x50 ,0x9F ,0xE5 ,
	 0xDC ,0x60 ,0x9F ,0xE5 ,0x00 ,0xB0 ,0xA0 ,0xE3 ,
	 0x02 ,0x0C ,0xA0 ,0xE3 ,0x00 ,0x40 ,0x60 ,0xE2 ,
	 0x18 ,0x00 ,0x99 ,0xE5 ,0x04 ,0x10 ,0x00 ,0xE0 ,
	 0x00 ,0x00 ,0x51 ,0xE1 ,0x05 ,0x00 ,0x00 ,0x1A ,
	 0x1C ,0x80 ,0x99 ,0xE5 ,0x03 ,0x00 ,0x18 ,0xE2
	};
	unsigned char arm9read2[] = 
	{
	 0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
	 0x00 ,0xA0 ,0xA0 ,0xE1 ,0xFC ,0x90 ,0x9F ,0xE5 ,
	 0xFC ,0x50 ,0x9F ,0xE5 ,0xFC ,0x60 ,0x9F ,0xE5 ,
	 0x20 ,0x70 ,0x8A ,0xE2 ,0x00 ,0xB0 ,0xA0 ,0xE3 ,
	 0x18 ,0x40 ,0x89 ,0xE2 ,0x18 ,0x20 ,0x99 ,0xE5 ,
	 0x02 ,0x0C ,0xA0 ,0xE3 ,0x00 ,0x00 ,0x60 ,0xE2 ,
	 0x00 ,0x10 ,0x02 ,0xE0 ,0x02 ,0x00 ,0x51 ,0xE1 ,
	 0x05 ,0x00 ,0x00 ,0x1A ,0x1C ,0x80 ,0x99 ,0xE5
	};
	unsigned char arm9read5[] = 
	{
	0xF0 ,0x47 ,0x2D ,0xE9 ,0x00 ,0x50 ,0xA0 ,0xE1 ,
	0xD4 ,0x40 ,0x9F ,0xE5 ,0x18 ,0x10 ,0x94 ,0xE5 ,
	0x02 ,0x0C ,0xA0 ,0xE3 ,0x00 ,0x00 ,0x60 ,0xE2 ,
	0x00 ,0x80 ,0x01 ,0xE0 ,0x18 ,0x00 ,0x94 ,0xE5 ,
	0x00 ,0x00 ,0x58 ,0xE1 ,0x06 ,0x00 ,0x00 ,0x1A ,
	0x1C ,0x00 ,0x94 ,0xE5 ,0x03 ,0x00 ,0x00 ,0xE2 ,
	0x00 ,0x00 ,0x50 ,0xE3 ,0x02 ,0x00 ,0x00 ,0x1A ,
	0x20 ,0x00 ,0x94 ,0xE5 ,0x02 ,0x0C ,0x50 ,0xE3
	};
	unsigned char arm9read6[] = 
	{
		0x70 ,0x40 ,0x2D ,0xE9 ,0xD0 ,0x40 ,0x9F ,0xE5 ,
		0x00 ,0x60 ,0xA0 ,0xE1 ,0x02 ,0x0C ,0xA0 ,0xE3 ,
		0x1C ,0x10 ,0x94 ,0xE5 ,0x00 ,0x00 ,0x60 ,0xE2 ,
		0x00 ,0x20 ,0x01 ,0xE0 ,0x01 ,0x00 ,0x52 ,0xE1 ,
		0x05 ,0x00 ,0x00 ,0x1A ,0x20 ,0x50 ,0x94 ,0xE5 ,
		0x03 ,0x00 ,0x15 ,0xE3 ,0x02 ,0x00 ,0x00 ,0x1A,
		0x24 ,0x00 ,0x94 ,0xE5 ,0x02 ,0x0C ,0x50 ,0xE3 ,
		0x01 ,0x00 ,0x00 ,0x2A ,0x08 ,0x20 ,0x86 ,0xE5
	};
	unsigned char arm9read_thumb1[] = 
	{
	0xF0 ,0xB5 ,0x83 ,0xB0 ,0x00 ,0x90 ,0x27 ,0x4E ,
	0x01 ,0x90 ,0x20 ,0x30 ,0x01 ,0x90 ,0x26 ,0x4F ,
	0x26 ,0x4C ,0xB2 ,0x69 ,0x11 ,0x1C ,0x26 ,0x48 ,
	0x01 ,0x40 ,0x91 ,0x42 ,0x08 ,0xD1 ,0xF5 ,0x69 ,
	0x2A ,0x1C ,0x03 ,0x20 ,0x02 ,0x40 ,0x00 ,0x2A ,
	0x02 ,0xD1 ,0x30 ,0x6A ,0xA0 ,0x42 ,0x02 ,0xD2 ,
	0x01 ,0x9D ,0x00 ,0x98 ,0x81 ,0x60 ,0x08 ,0x0A ,
	0x1E ,0x4A ,0x10 ,0x43 ,0x09 ,0x06 ,0x00 ,0xF0
	};
	unsigned char arm9read_thumb2[] = 
	{
	0xF0 ,0xB5 ,0x83 ,0xB0 ,0x00 ,0x90 ,0x27 ,0x4E ,
	0x01 ,0x90 ,0x20 ,0x30 ,0x01 ,0x90 ,0x26 ,0x4F ,
	0x26 ,0x4C ,0xF2 ,0x69 ,0x11 ,0x1C ,0x26 ,0x48 ,
	0x01 ,0x40 ,0x91 ,0x42 ,0x08 ,0xD1 ,0x35 ,0x6A ,
	0x2A ,0x1C ,0x03 ,0x20 ,0x02 ,0x40 ,0x00 ,0x2A ,
	0x02 ,0xD1 ,0x70 ,0x6A ,0xA0 ,0x42 ,0x02 ,0xD2 ,
	0x01 ,0x9D ,0x00 ,0x98 ,0x81 ,0x60 ,0x08 ,0x0A ,
	0x1E ,0x4A ,0x10 ,0x43 ,0x09 ,0x06 ,0x00 ,0xF0
	};
	unsigned char arm9read_thumb3[]=
	{
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x00 ,0x90 ,0x25 ,0x4E ,
		0x01 ,0x90 ,0x20 ,0x30 ,0x01 ,0x90 ,0x24 ,0x4F ,
		0x24 ,0x4C ,0xB2 ,0x69 ,0x11 ,0x1C ,0x24 ,0x48 ,
		0x01 ,0x40 ,0x91 ,0x42 ,0x08 ,0xD1 ,0xF5 ,0x69 ,
		0x2A ,0x1C ,0x03 ,0x20 ,0x02 ,0x40 ,0x00 ,0x2A ,
		0x02 ,0xD1 ,0x30 ,0x6A ,0xA0 ,0x42 ,0x02 ,0xD2 ,
		0x01 ,0x9D ,0x00 ,0x98 ,0x81 ,0x60 ,0x08 ,0x0A ,
		0x1C ,0x4A ,0x10 ,0x43 ,0x09 ,0x06 ,0x00 ,0xF0
	};

	unsigned char arm7read[] = 
	{
	0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
	0x00 ,0xA0 ,0xA0 ,0xE1 ,0xD8 ,0x90 ,0x9F ,0xE5 ,
	0x20 ,0x70 ,0x8A ,0xE2 ,0xD4 ,0xB0 ,0x9F ,0xE5 ,
	0xD4 ,0x50 ,0x9F ,0xE5 ,0x00 ,0x60 ,0xA0 ,0xE3 ,
	0x02 ,0x0C ,0xA0 ,0xE3 ,0x00 ,0x40 ,0x60 ,0xE2 ,
	0x20 ,0x00 ,0x99 ,0xE5 ,0x04 ,0x10 ,0x00 ,0xE0 ,
	0x00 ,0x00 ,0x51 ,0xE1 ,0x05 ,0x00 ,0x00 ,0x1A ,
	0x24 ,0x80 ,0x99 ,0xE5 ,0x03 ,0x00 ,0x18 ,0xE2
	};

	unsigned char arm9read3[] = 
	{0xF0, 0x4F, 0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
	 0x00 ,0xA0 ,0xA0 ,0xE1 ,0xE0 ,0x90 ,0x9F ,0xE5 ,
	 0x20 ,0x70 ,0x8A ,0xE2 ,0xDC ,0x50 ,0x9F ,0xE5 ,
	 0xDC ,0x60 ,0x9F ,0xE5 ,0x00 ,0xB0 ,0xA0 ,0xE3 ,
	 0x02 ,0x0C ,0xA0 ,0xE3 ,0x00 ,0x40 ,0x60 ,0xE2 ,
	 0x1C ,0x00 ,0x99 ,0xE5 ,0x04 ,0x10 ,0x00 ,0xE0 ,
	 0x00 ,0x00 ,0x51 ,0xE1 ,0x05 ,0x00 ,0x00 ,0x1A ,
	 0x20 ,0x80 ,0x99 ,0xE5 ,0x03 ,0x00 ,0x18 ,0xE2
	};
	unsigned char arm9read4[] = 
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0xD8 ,0x90 ,0x9F ,0xE5 ,
		0x20 ,0x70 ,0x8A ,0xE2 ,0xD4 ,0x50 ,0x9F ,0xE5 ,
		0xD4 ,0x60 ,0x9F ,0xE5 ,0x00 ,0xB0 ,0xA0 ,0xE3 ,
		0x02 ,0x0C ,0xA0 ,0xE3 ,0x00 ,0x40 ,0x60 ,0xE2 ,
		0x1C ,0x00 ,0x99 ,0xE5 ,0x04 ,0x10 ,0x00 ,0xE0 ,
		0x00 ,0x00 ,0x51 ,0xE1 ,0x05 ,0x00 ,0x00 ,0x1A ,
		0x20 ,0x80 ,0x99 ,0xE5 ,0x03 ,0x00 ,0x18 ,0xE2
	};
	unsigned char arm9anotherRead[] =
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0xE4 ,0x40 ,0x9F ,0xE5 ,0xE4 ,0x30 ,0x9F ,0xE5 ,
		0x00 ,0x40 ,0x94 ,0xE5 ,0x03 ,0x30 ,0x00 ,0xE0 ,
		0x07 ,0x44 ,0xC4 ,0xE3 ,0xA1 ,0xA4 ,0x84 ,0xE3 ,
		0x00 ,0x90 ,0x63 ,0xE2 ,0xD0 ,0x40 ,0x9F ,0xE5 ,
		0x00 ,0x30 ,0x94 ,0xE5 ,0x02 ,0x31 ,0x13 ,0xE2 ,
		0xFC ,0xFF ,0xFF ,0x1A ,0xC4 ,0x30 ,0x9F ,0xE5 ,
		0x80 ,0x40 ,0xA0 ,0xE3 ,0x02 ,0x00 ,0x59 ,0xE1
	};
	unsigned char arm9anotherRead2[] =
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0xEC ,0x40 ,0x9F ,0xE5 ,0xEC ,0x30 ,0x9F ,0xE5 ,
		0x00 ,0x40 ,0x94 ,0xE5 ,0x03 ,0x30 ,0x00 ,0xE0 ,
		0x07 ,0x44 ,0xC4 ,0xE3 ,0xA1 ,0xA4 ,0x84 ,0xE3 ,
		0x00 ,0x90 ,0x63 ,0xE2 ,0xD8 ,0x40 ,0x9F ,0xE5 ,
		0x00 ,0x30 ,0x94 ,0xE5 ,0x02 ,0x31 ,0x13 ,0xE2 ,
		0xFC ,0xFF ,0xFF ,0x1A ,0xCC ,0x30 ,0x9F ,0xE5 ,
		0x80 ,0x40 ,0xA0 ,0xE3 ,0x02 ,0x00 ,0x59 ,0xE1
	};

	unsigned char stack1[] = {0x00,0x00,0x3C,0x02} ;
	unsigned char stack2[] = {0x00,0x00,0x7C,0x02} ;
	unsigned char stack3[] = {0x00,0x00,0x7E,0x02} ;
	unsigned char stack4[] = {0x00,0x00,0x3E,0x02} ;
	unsigned char compress[] = 
	{
/*		0x00 ,0x00 ,0x50 ,0xE3 ,0x25 ,0x00 ,0x00 ,0x0A ,
		0xF0 ,0x00 ,0x2D ,0xE9 ,0x06 ,0x00 ,0x10 ,0xE9 ,
		0x02 ,0x20 ,0x80 ,0xE0 ,0x21 ,0x3C ,0x40 ,0xE0 ,
		0xFF ,0x14 ,0xC1 ,0xE3 ,0x01 ,0x10 ,0x40 ,0xE0 ,
		0x02 ,0x40 ,0xA0 ,0xE1 ,0x01 ,0x00 ,0x53 ,0xE1 ,
		0x15 ,0x00 ,0x00 ,0xDA ,0x01 ,0x50 ,0x73 ,0xE5 ,
		0x08 ,0x60 ,0xA0 ,0xE3 ,0x01 ,0x60 ,0x56 ,0xE2 ,
		0xF9 ,0xFF ,0xFF ,0xBA ,0x80 ,0x00 ,0x15 ,0xE3
*/
		0xF0 ,0x00 ,0x2D ,0xE9 ,0x06 ,0x00 ,0x10 ,0xE9 ,
		0x02 ,0x20 ,0x80 ,0xE0 ,0x21 ,0x3C ,0x40 ,0xE0 ,
		0xFF ,0x14 ,0xC1 ,0xE3 ,0x01 ,0x10 ,0x40 ,0xE0 ,
		0x02 ,0x40 ,0xA0 ,0xE1 ,0x01 ,0x00 ,0x53 ,0xE1 ,
		0x15 ,0x00 ,0x00 ,0xDA ,0x01 ,0x50 ,0x73 ,0xE5 ,
		0x08 ,0x60 ,0xA0 ,0xE3 ,0x01 ,0x60 ,0x56 ,0xE2 ,
		0xF9 ,0xFF ,0xFF ,0xBA ,0x80 ,0x00 ,0x15 ,0xE3 ,
		0x02 ,0x00 ,0x00 ,0x1A ,0x01 ,0x00 ,0x73 ,0xE5
	};
	unsigned char ReadSaver_550[] =
	{
		0x34 ,0x00 ,0x96 ,0xE5 ,0x04 ,0x00 ,0x10 ,0xE2 ,
		0xFA ,0xFF ,0xFF ,0x1A ,0x34 ,0x20 ,0x86 ,0xE2 ,
		0x00 ,0x10 ,0x92 ,0xE5 ,0x05 ,0x00 ,0xA0 ,0xE1 ,
		0x04 ,0x10 ,0x81 ,0xE3 ,0x00 ,0x10 ,0x82 ,0xE5 ,
		0x8A ,0xEA ,0xFF ,0xEB ,0x18 ,0xA0 ,0x86 ,0xE5 ,
		0x1C ,0x90 ,0x86 ,0xE5 ,0x20 ,0x80 ,0x86 ,0xE5 ,
		0x24 ,0x00 ,0x9D ,0xE5 ,0x20 ,0x10 ,0x9D ,0xE5 ,
		0x28 ,0x70 ,0x86 ,0xE5 ,0x2C ,0x10 ,0x86 ,0xE5
	};
	unsigned char ReadSaver_550_2[] =
	{
		0x34 ,0x00 ,0x96 ,0xE5 ,0x04 ,0x00 ,0x10 ,0xE2 ,
		0xFA ,0xFF ,0xFF ,0x1A ,0x34 ,0x10 ,0x96 ,0xE5 ,
		0x05 ,0x00 ,0xA0 ,0xE1 ,0x04 ,0x10 ,0x81 ,0xE3 ,
		0x34 ,0x10 ,0x86 ,0xE5 ,0x9B ,0xE3 ,0xFF ,0xEB ,
		0x18 ,0xA0 ,0x86 ,0xE5 ,0x1C ,0x90 ,0x86 ,0xE5 ,
		0x20 ,0x80 ,0x86 ,0xE5 ,0x24 ,0x00 ,0x9D ,0xE5 ,
		0x20 ,0x10 ,0x9D ,0xE5 ,0x28 ,0x70 ,0x86 ,0xE5 ,
		0x2C ,0x10 ,0x86 ,0xE5 ,0x00 ,0x00 ,0x50 ,0xE3	
	};
	unsigned char ReadSaver_550thumb[] =
	{
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x1F ,0x4D ,0xF9 ,0xF7 ,
		0xC0 ,0xE9 ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0xF8 ,0xF7 ,0xA1 ,0xF8 ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x69 ,0x6B ,
		0x04 ,0x20 ,0x01 ,0x43 ,0x69 ,0x63 ,0x02 ,0x98 ,
		0xF9 ,0xF7 ,0xB4 ,0xE9 ,0xAE ,0x61 ,0xEF ,0x61
	};
	unsigned char ReadSaver_550thumb_2[] =
	{
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x20 ,0x4D ,0xF9 ,0xF7 ,
		0x64 ,0xEC ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0xF8 ,0xF7 ,0xA7 ,0xFC ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x2A ,0x1C ,
		0x34 ,0x32 ,0x11 ,0x68 ,0x04 ,0x20 ,0x01 ,0x43 ,
		0x11 ,0x60 ,0x02 ,0x98 ,0xF9 ,0xF7 ,0x56 ,0xEC
	};
	unsigned char ReadSaver_550thumb_3[] =
	{
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x1F ,0x4D ,0xF9 ,0xF7 ,
		0x06 ,0xEB ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0xF8 ,0xF7 ,0x53 ,0xFB ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x69 ,0x6B ,
		0x04 ,0x20 ,0x01 ,0x43 ,0x69 ,0x63 ,0x02 ,0x98 ,
		0xF9 ,0xF7 ,0xFA ,0xEA ,0xAE ,0x61 ,0xEF ,0x61
	};
	unsigned char ReadSaver_550thumb_4[] =
	{
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x20 ,0x4D ,0xFE ,0xF7 ,
		0xB5 ,0xFF ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0x03 ,0xF0 ,0xB7 ,0xFC ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x2A ,0x1C ,
		0x34 ,0x32 ,0x11 ,0x68 ,0x04 ,0x20 ,0x01 ,0x43 ,
		0x11 ,0x60 ,0x02 ,0x98 ,0xFE ,0xF7 ,0xA4 ,0xFF
	};
	unsigned char WriteSaver_47c[]=
	{
		0x34 ,0x00 ,0x96 ,0xE5 ,0x04 ,0x00 ,0x10 ,0xE2 ,
		0xFA ,0xFF ,0xFF ,0x1A ,0x34 ,0x20 ,0x86 ,0xE2 ,
		0x00 ,0x10 ,0x92 ,0xE5 ,0x05 ,0x00 ,0xA0 ,0xE1 ,
		0x04 ,0x10 ,0x81 ,0xE3 ,0x00 ,0x10 ,0x82 ,0xE5 ,
		0xBF ,0xEA ,0xFF ,0xEB ,0x18 ,0x90 ,0x86 ,0xE5 ,
		0x1C ,0xA0 ,0x86 ,0xE5 ,0x20 ,0x80 ,0x86 ,0xE5 ,
		0x24 ,0x00 ,0x9D ,0xE5 ,0x20 ,0x10 ,0x9D ,0xE5 ,
		0x28 ,0x70 ,0x86 ,0xE5 ,0x2C ,0x10 ,0x86 ,0xE5
	};
	unsigned char WriteSaver_47c_2[]=
	{
		0x34 ,0x00 ,0x96 ,0xE5 ,0x04 ,0x00 ,0x10 ,0xE2 ,
		0xFA ,0xFF ,0xFF ,0x1A ,0x34 ,0x10 ,0x96 ,0xE5 ,
		0x05 ,0x00 ,0xA0 ,0xE1 ,0x04 ,0x10 ,0x81 ,0xE3 ,
		0x34 ,0x10 ,0x86 ,0xE5 ,0xCF ,0xE3 ,0xFF ,0xEB ,
		0x18 ,0x90 ,0x86 ,0xE5 ,0x1C ,0xA0 ,0x86 ,0xE5 ,
		0x20 ,0x80 ,0x86 ,0xE5 ,0x24 ,0x00 ,0x9D ,0xE5 ,
		0x20 ,0x10 ,0x9D ,0xE5 ,0x28 ,0x70 ,0x86 ,0xE5 ,
		0x2C ,0x10 ,0x86 ,0xE5 ,0x00 ,0x00 ,0x50 ,0xE3	
	};

	unsigned char write_verifycore[] = 
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0xE0 ,0x80 ,0x8A ,0xE2 ,
		0x01 ,0x7C ,0xA0 ,0xE3 ,0x08 ,0x60 ,0xA0 ,0xE3 ,
		0x0A ,0x50 ,0xA0 ,0xE3 ,0x09 ,0xB0 ,0xA0 ,0xE3 ,
		0x01 ,0x00 ,0xA0 ,0xE3 ,0x00 ,0x00 ,0x8D ,0xE5 ,
		0x18 ,0x40 ,0x8A ,0xE2 ,0x20 ,0x90 ,0x9A ,0xE5 ,
		0x18 ,0x00 ,0x9A ,0xE5 ,0x01 ,0x0C ,0x59 ,0xE3 ,
		0x07 ,0x90 ,0xA0 ,0x81 ,0x08 ,0x10 ,0xA0 ,0xE1	
	};
	unsigned char write_verifycore_2[] = 
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0xE0 ,0x80 ,0x8A ,0xE2 ,
		0x18 ,0x60 ,0x8A ,0xE2 ,0x01 ,0x7C ,0xA0 ,0xE3 ,
		0x09 ,0xB0 ,0xA0 ,0xE3 ,0x01 ,0x00 ,0xA0 ,0xE3 ,
		0x00 ,0x00 ,0x8D ,0xE5 ,0x1C ,0x50 ,0x8A ,0xE2 ,
		0x20 ,0x40 ,0x8A ,0xE2 ,0x20 ,0x90 ,0x9A ,0xE5 ,
		0x18 ,0x00 ,0x9A ,0xE5 ,0x01 ,0x0C ,0x59 ,0xE3 ,
		0x07 ,0x90 ,0xA0 ,0x81 ,0x08 ,0x10 ,0xA0 ,0xE1
	};

	unsigned char WriteSaver_47cthumb[] = 
	{//168存档暂不支持
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x1F ,0x4D ,0xF9 ,0xF7 ,
		0x0E ,0xEA ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0xF8 ,0xF7 ,0xEF ,0xF8 ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x69 ,0x6B ,
		0x04 ,0x20 ,0x01 ,0x43 ,0x69 ,0x63 ,0x02 ,0x98 ,
		0xF9 ,0xF7 ,0x02 ,0xEA ,0xAF ,0x61 ,0xEE ,0x61	
	};
	unsigned char WriteSaver_47cthumb_2[] = 
	{//168存档暂不支持
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x20 ,0x4D ,0xF9 ,0xF7 ,
		0xB4 ,0xEC ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0xF8 ,0xF7 ,0xF7 ,0xFC ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x2A ,0x1C ,
		0x34 ,0x32 ,0x11 ,0x68 ,0x04 ,0x20 ,0x01 ,0x43 ,
		0x11 ,0x60 ,0x02 ,0x98 ,0xF9 ,0xF7 ,0xA6 ,0xEC
	};
	unsigned char WriteSaver_47cthumb_3[] = 
	{//
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x1F ,0x4D ,0xF9 ,0xF7 ,
		0x54 ,0xEB ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0xF8 ,0xF7 ,0xA1 ,0xFB ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x69 ,0x6B ,
		0x04 ,0x20 ,0x01 ,0x43 ,0x69 ,0x63 ,0x02 ,0x98 ,
		0xF9 ,0xF7 ,0x48 ,0xEB ,0xAF ,0x61 ,0xEE ,0x61
	};
	unsigned char WriteSaver_47cthumb_4[] = 
	{//
		0xF0 ,0xB5 ,0x83 ,0xB0 ,0x06 ,0x1C ,0x0F ,0x1C ,
		0x00 ,0x92 ,0x01 ,0x93 ,0x20 ,0x4D ,0xFF ,0xF7 ,
		0x05 ,0xF8 ,0x02 ,0x90 ,0x68 ,0x6B ,0x04 ,0x24 ,
		0x20 ,0x40 ,0x00 ,0x28 ,0x07 ,0xD0 ,0x28 ,0x1C ,
		0xD4 ,0x30 ,0x03 ,0xF0 ,0x07 ,0xFD ,0x68 ,0x6B ,
		0x20 ,0x40 ,0x00 ,0x28 ,0xF7 ,0xD1 ,0x2A ,0x1C ,
		0x34 ,0x32 ,0x11 ,0x68 ,0x04 ,0x20 ,0x01 ,0x43 ,
		0x11 ,0x60 ,0x02 ,0x98 ,0xFE ,0xF7 ,0xF4 ,0xFF
	};
	unsigned char arm9_cardexist[] = 
	{
		0x00 ,0x40 ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x2E ,0x03 ,0xA0 ,0xE3 ,0x00 ,0x10 ,0xA0 ,0xE3 ,
		0xF6 ,0x00 ,0x00 ,0xEB ,0x3C ,0x10 ,0x9F ,0xE5 ,
		0x02 ,0x0A ,0xA0 ,0xE3 ,0x00 ,0x10 ,0x91 ,0xE5 ,
		0x00 ,0x00 ,0x60 ,0xE2 ,0x07 ,0x14 ,0xC1 ,0xE3 ,
		0xA7 ,0x24 ,0x81 ,0xE3 ,0x28 ,0x10 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x02 ,0xE0 ,0x00 ,0x00 ,0x81 ,0xE5 ,
		0x00 ,0x00 ,0x91 ,0xE5 ,0x02 ,0x05 ,0x10 ,0xE2
	};
	unsigned char arm9_cardexist_1[] = 
	{
		0x00 ,0x40 ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x2E ,0x03 ,0xA0 ,0xE3 ,0x00 ,0x10 ,0xA0 ,0xE3 ,
		0xF0 ,0x00 ,0x00 ,0xEB ,0x38 ,0x10 ,0x9F ,0xE5 ,
		0x02 ,0x0A ,0xA0 ,0xE3 ,0x00 ,0x10 ,0x91 ,0xE5 ,
		0x00 ,0x00 ,0x60 ,0xE2 ,0x07 ,0x14 ,0xC1 ,0xE3 ,
		0xA7 ,0x24 ,0x81 ,0xE3 ,0x24 ,0x10 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x02 ,0xE0 ,0x00 ,0x00 ,0x81 ,0xE5 ,
		0x00 ,0x00 ,0x91 ,0xE5 ,0x02 ,0x05 ,0x10 ,0xE2
	};
	unsigned char arm9_cardexist_2[] = 
	{
		0x08 ,0x40 ,0x2D ,0xE9 ,0x2E ,0x03 ,0xA0 ,0xE3 ,
		0x00 ,0x10 ,0xA0 ,0xE3 ,0x08 ,0xFF ,0xFF ,0xEB ,
		0x34 ,0x10 ,0x9F ,0xE5 ,0x02 ,0x0A ,0xA0 ,0xE3 ,
		0x00 ,0x10 ,0x91 ,0xE5 ,0x00 ,0x00 ,0x60 ,0xE2 ,
		0x07 ,0x14 ,0xC1 ,0xE3 ,0xA7 ,0x24 ,0x81 ,0xE3 ,
		0x20 ,0x10 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x02 ,0xE0 ,
		0x00 ,0x00 ,0x81 ,0xE5 ,0x00 ,0x00 ,0x91 ,0xE5 ,
		0x02 ,0x05 ,0x10 ,0xE3 ,0xFC ,0xFF ,0xFF ,0x0A
	};
	unsigned char arm9_thumbcardexist[] = 
	{
		0x00 ,0xB5 ,0x81 ,0xB0 ,0x0B ,0x48 ,0x00 ,0x21 ,
		0x00 ,0xF0 ,0x8A ,0xF9 ,0x0A ,0x48 ,0x01 ,0x68 ,
		0x0A ,0x48 ,0x01 ,0x40 ,0x0A ,0x48 ,0x01 ,0x43 ,
		0x0A ,0x48 ,0x01 ,0x40 ,0x0A ,0x4A ,0x11 ,0x60 ,
		0x0A ,0x48 ,0x11 ,0x68 ,0x01 ,0x40 ,0x00 ,0x29 ,
		0xFB ,0xD0 ,0x09 ,0x48 ,0x00 ,0x68 ,0x01 ,0xB0 ,
		0x08 ,0xBC ,0x18 ,0x47 ,0x00 ,0x00 ,0x00 ,0xB8 ,
		0x60 ,0xFE ,0x7F ,0x02 ,0xFF ,0xFF ,0xFF ,0xF8
	};

	unsigned char arm9_thumbcardexist2[] = 
	{
		0x00 ,0xB5 ,0x81 ,0xB0 ,0x0B ,0x48 ,0x00 ,0x21 ,
		0x00 ,0xF0 ,0x58 ,0xF9 ,0x0A ,0x48 ,0x01 ,0x68 ,
		0x0A ,0x48 ,0x01 ,0x40 ,0x0A ,0x48 ,0x01 ,0x43 ,
		0x0A ,0x48 ,0x01 ,0x40 ,0x0A ,0x4A ,0x11 ,0x60 ,
		0x0A ,0x48 ,0x11 ,0x68 ,0x01 ,0x40 ,0x00 ,0x29 ,
		0xFB ,0xD0 ,0x09 ,0x48 ,0x00 ,0x68 ,0x01 ,0xB0 ,
		0x08 ,0xBC ,0x18 ,0x47 ,0x00 ,0x00 ,0x00 ,0xB8 ,
		0x60 ,0xFE ,0x7F ,0x02 ,0xFF ,0xFF ,0xFF ,0xF8
	};

	unsigned char arm7_checkcard[] = 
	{
		0x00 ,0x40 ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x48 ,0x00 ,0x9F ,0xE5 ,0xB0 ,0x00 ,0xD0 ,0xE1 ,
		0x00 ,0x00 ,0x50 ,0xE3 ,0x40 ,0x00 ,0x9F ,0x05 ,
		0x40 ,0x00 ,0x9F ,0x15 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x00 ,0x00 ,0x8D ,0xE5 ,0xF1 ,0xFD ,0xFF ,0xEB ,
		0x00 ,0x10 ,0x9D ,0xE5 ,0x01 ,0x00 ,0x50 ,0xE1 ,
		0x01 ,0x00 ,0xA0 ,0x03 ,0x00 ,0x00 ,0xA0 ,0x13 ,
		0x00 ,0x00 ,0x50 ,0xE3 ,0x01 ,0x20 ,0xA0 ,0x03
	};

	unsigned char arm7_readrom512[] = 
	{
		0x00 ,0x40 ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x54 ,0xE0 ,0x9F ,0xE5 ,0x54 ,0xC0 ,0x9F ,0xE5 ,
		0x04 ,0x30 ,0xA0 ,0xE3 ,0x28 ,0x30 ,0x8C ,0xE5 ,
		0x1C ,0x00 ,0x8C ,0xE5 ,0x20 ,0x10 ,0x8C ,0xE5 ,
		0x24 ,0x20 ,0x8C ,0xE5 ,0x00 ,0x00 ,0xA0 ,0xE3 ,
		0x38 ,0x00 ,0x8C ,0xE5 ,0x3C ,0x00 ,0x8C ,0xE5 ,
		0x34 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x07 ,0x04 ,0xC0 ,0xE3 ,0xA1 ,0x04 ,0x80 ,0xE3
	};

	unsigned char arm7_readrom512_1[] = 
	{
		0x10 ,0x40 ,0x2D ,0xE9 ,0x5C ,0x40 ,0x9F ,0xE5 ,
		0x5C ,0xC0 ,0x9F ,0xE5 ,0x28 ,0x00 ,0x8C ,0xE5 ,
		0x1C ,0x10 ,0x8C ,0xE5 ,0x20 ,0x20 ,0x8C ,0xE5 ,
		0x24 ,0x30 ,0x8C ,0xE5 ,0x00 ,0x10 ,0xA0 ,0xE3 ,
		0x2C ,0x10 ,0x8C ,0xE5 ,0x30 ,0x10 ,0x8C ,0xE5 ,
		0x03 ,0x00 ,0x50 ,0xE3 ,0x00 ,0x00 ,0x00 ,0x8A ,
		0x27 ,0xEA ,0xFF ,0xEB ,0x34 ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0x07 ,0x04 ,0xC0 ,0xE3
	};

	unsigned char arm7_readcard[]=
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0xD8 ,0x90 ,0x9F ,0xE5 ,
		0x20 ,0x70 ,0x8A ,0xE2 ,0xD4 ,0xB0 ,0x9F ,0xE5 ,
		0xD4 ,0x50 ,0x9F ,0xE5 ,0x00 ,0x60 ,0xA0 ,0xE3 ,
		0x02 ,0x0C ,0xA0 ,0xE3 ,0x00 ,0x40 ,0x60 ,0xE2 ,
		0x1C ,0x00 ,0x99 ,0xE5 ,0x04 ,0x10 ,0x00 ,0xE0 ,
		0x00 ,0x00 ,0x51 ,0xE1 ,0x05 ,0x00 ,0x00 ,0x1A ,
		0x20 ,0x80 ,0x99 ,0xE5 ,0x03 ,0x00 ,0x18 ,0xE2
	};

	unsigned char arm7_erasesram[]=
	{
		0x10 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x40 ,0xA0 ,0xE1 ,
		0x97 ,0x01 ,0x00 ,0xEB ,0x23 ,0x01 ,0x00 ,0xEB ,
		0x34 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x24 ,0x00 ,0x90 ,0xE5 ,0x01 ,0x00 ,0x80 ,0xE2 ,
		0xCF ,0x01 ,0x00 ,0xEB ,0x04 ,0x00 ,0xA0 ,0xE1 ,
		0xD8 ,0x10 ,0xA0 ,0xE3 ,0xF0 ,0x00 ,0x00 ,0xEB ,
		0x14 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x38 ,0x00 ,0x90 ,0xE5 ,0x00 ,0x10 ,0xA0 ,0xE3
	};

	unsigned char arm7_erasesram_a[]=
	{
		0x10 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x40 ,0xA0 ,0xE1 ,
		0x58 ,0x01 ,0x00 ,0xEB ,0xE4 ,0x00 ,0x00 ,0xEB ,
		0x34 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x24 ,0x00 ,0x90 ,0xE5 ,0x01 ,0x00 ,0x80 ,0xE2 ,
		0x90 ,0x01 ,0x00 ,0xEB ,0x04 ,0x00 ,0xA0 ,0xE1 ,
		0xD8 ,0x10 ,0xA0 ,0xE3 ,0xB1 ,0x00 ,0x00 ,0xEB ,
		0x14 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x38 ,0x00 ,0x90 ,0xE5 ,0x00 ,0x10 ,0xA0 ,0xE3
	};

	unsigned char arm7_erasesram1[]=
	{
		0x10 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x40 ,0xA0 ,0xE1 ,
		0x99 ,0x01 ,0x00 ,0xEB ,0x00 ,0x00 ,0x50 ,0xE3 ,
		0x0D ,0x00 ,0x00 ,0x0A ,0x23 ,0x01 ,0x00 ,0xEB ,
		0x34 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x24 ,0x00 ,0x90 ,0xE5 ,0x01 ,0x00 ,0x80 ,0xE2 ,
		0xDB ,0x01 ,0x00 ,0xEB ,0x04 ,0x00 ,0xA0 ,0xE1 ,
		0xD8 ,0x10 ,0xA0 ,0xE3 ,0xF0 ,0x00 ,0x00 ,0xEB ,
		0x14 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5
	};
	unsigned char arm7_erasesram2[]=
	{
		0x10 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x40 ,0xA0 ,0xE1 ,
		0x6C ,0x01 ,0x00 ,0xEB ,0xF2 ,0x00 ,0x00 ,0xEB ,
		0x30 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x01 ,0x00 ,0x80 ,0xE2 ,0xA5 ,0x01 ,0x00 ,0xEB ,
		0x04 ,0x00 ,0xA0 ,0xE1 ,0xD8 ,0x10 ,0xA0 ,0xE3 ,
		0xC1 ,0x00 ,0x00 ,0xEB ,0x18 ,0x00 ,0x9F ,0xE5
	};
	unsigned char arm7_erase3[]=
	{
		0xF0 ,0x41 ,0x2D ,0xE9 ,0x00 ,0x70 ,0xA0 ,0xE1 ,
		0x01 ,0x60 ,0xA0 ,0xE1 ,0x7C ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x50 ,0x90 ,0xE5 ,0x1C ,0x40 ,0x95 ,0xE5 ,
		0x01 ,0x10 ,0x44 ,0xE2 ,0x06 ,0x00 ,0x87 ,0xE1 ,
		0x00 ,0x00 ,0x11 ,0xE0 ,0x02 ,0x00 ,0xA0 ,0x13 ,
		0x00 ,0x00 ,0x85 ,0x15 ,0x15 ,0x00 ,0x00 ,0x1A ,
		0x88 ,0x01 ,0x00 ,0xEB ,0x00 ,0x00 ,0x50 ,0xE3 ,
		0x12 ,0x00 ,0x00 ,0x0A ,0xD8 ,0x80 ,0xA0 ,0xE3
	};
	unsigned char arm7_erasesram4[]=
	{
		0x10 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x40 ,0xA0 ,0xE1 ,
		0x85 ,0x01 ,0x00 ,0xEB ,0x00 ,0x00 ,0x50 ,0xE3 ,
		0x0D ,0x00 ,0x00 ,0x0A ,0x0F ,0x01 ,0x00 ,0xEB ,
		0x34 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x24 ,0x00 ,0x90 ,0xE5 ,0x01 ,0x00 ,0x80 ,0xE2 ,
		0xAF ,0x01 ,0x00 ,0xEB ,0x04 ,0x00 ,0xA0 ,0xE1 ,
		0xD8 ,0x10 ,0xA0 ,0xE3 ,0xDC ,0x00 ,0x00 ,0xEB ,
		0x14 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5	
	};
	unsigned char arm7_verifysram[]=
	{
		0x70 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x60 ,0xA0 ,0xE1 ,
		0x01 ,0x50 ,0xA0 ,0xE1 ,0x02 ,0x40 ,0xA0 ,0xE1 ,
		0x81 ,0x01 ,0x00 ,0xEB ,0x01 ,0x10 ,0xA0 ,0xE3 ,
		0x74 ,0x00 ,0x9F ,0xE5 ,0x0C ,0x10 ,0x80 ,0xE5 ,
		0x70 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x24 ,0x00 ,0x90 ,0xE5 ,0x01 ,0x00 ,0x80 ,0xE2 ,
		0x04 ,0x00 ,0x80 ,0xE0 ,0xB6 ,0x01 ,0x00 ,0xEB ,
		0x06 ,0x00 ,0xA0 ,0xE1 ,0x03 ,0x10 ,0xA0 ,0xE3
	};
	unsigned char arm7_verifysram1[]=
	{
		0x70 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x60 ,0xA0 ,0xE1 ,
		0x01 ,0x50 ,0xA0 ,0xE1 ,0x02 ,0x40 ,0xA0 ,0xE1 ,
		0x81 ,0x01 ,0x00 ,0xEB ,0x00 ,0x00 ,0x50 ,0xE3 ,
		0x1D ,0x00 ,0x00 ,0x0A ,0x01 ,0x10 ,0xA0 ,0xE3 ,
		0x74 ,0x00 ,0x9F ,0xE5 ,0x0C ,0x10 ,0x80 ,0xE5 ,
		0x70 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x24 ,0x00 ,0x90 ,0xE5 ,0x01 ,0x00 ,0x80 ,0xE2 ,
		0x04 ,0x00 ,0x80 ,0xE0 ,0xC0 ,0x01 ,0x00 ,0xEB
	};
	unsigned char arm7_verifysram2[]=
	{
		0x70 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x60 ,0xA0 ,0xE1 ,
		0x01 ,0x50 ,0xA0 ,0xE1 ,0x02 ,0x40 ,0xA0 ,0xE1 ,
		0x56 ,0x01 ,0x00 ,0xEB ,0x01 ,0x10 ,0xA0 ,0xE3 ,
		0x74 ,0x00 ,0x9F ,0xE5 ,0x10 ,0x10 ,0x80 ,0xE5 ,
		0xD9 ,0x00 ,0x00 ,0xEB ,0x68 ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0x01 ,0x00 ,0x80 ,0xE2 ,
		0x04 ,0x00 ,0x80 ,0xE0 ,0x8B ,0x01 ,0x00 ,0xEB ,
		0x06 ,0x00 ,0xA0 ,0xE1 ,0x03 ,0x10 ,0xA0 ,0xE3
	};
	unsigned char ar7_verifysram3[] = 
	{
		0xF0 ,0x40 ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0x70 ,0xA0 ,0xE1 ,0x01 ,0x60 ,0xA0 ,0xE1 ,
		0x02 ,0x50 ,0xA0 ,0xE1 ,0x6A ,0x01 ,0x00 ,0xEB ,
		0x00 ,0x00 ,0x50 ,0xE3 ,0x1B ,0x00 ,0x00 ,0x0A ,
		0x74 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x40 ,0x90 ,0xE5 ,
		0x01 ,0x10 ,0xA0 ,0xE3 ,0x6C ,0x00 ,0x9F ,0xE5 ,
		0x0C ,0x10 ,0x80 ,0xE5 ,0x24 ,0x00 ,0x94 ,0xE5 ,
		0x01 ,0x00 ,0x80 ,0xE2 ,0x05 ,0x00 ,0x80 ,0xE0
	};
	unsigned char arm7_writesram_a[]=
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0x01 ,0x90 ,0xA0 ,0xE1 ,
		0x02 ,0x80 ,0xA0 ,0xE1 ,0xAC ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0x20 ,0x70 ,0x90 ,0xE5 ,
		0x55 ,0x01 ,0x00 ,0xEB ,0x01 ,0x50 ,0x47 ,0xE2 ,
		0x0A ,0x40 ,0xA0 ,0xE3 ,0x00 ,0xB0 ,0xA0 ,0xE3 ,
		0x1F ,0x00 ,0x00 ,0xEA ,0x05 ,0x00 ,0x0A ,0xE0 ,
		0x00 ,0x60 ,0x47 ,0xE0 ,0x08 ,0x00 ,0x56 ,0xE1
	};
	unsigned char arm7_writesram_a2[]=
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0x01 ,0x90 ,0xA0 ,0xE1 ,
		0x02 ,0x80 ,0xA0 ,0xE1 ,0xA8 ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0xBC ,0x70 ,0xD0 ,0xE1 ,
		0x2A ,0x01 ,0x00 ,0xEB ,0x01 ,0x50 ,0x47 ,0xE2 ,
		0x0A ,0x40 ,0xA0 ,0xE3 ,0x00 ,0xB0 ,0xA0 ,0xE3 ,
		0x1E ,0x00 ,0x00 ,0xEA ,0x05 ,0x00 ,0x0A ,0xE0 ,
		0x00 ,0x60 ,0x47 ,0xE0 ,0x08 ,0x00 ,0x56 ,0xE1
	};
	unsigned char arm7_writesram_a1[]=
	{
		0xF0 ,0x41 ,0x2D ,0xE9 ,0x00 ,0x80 ,0xA0 ,0xE1 ,
		0x01 ,0x70 ,0xA0 ,0xE1 ,0x02 ,0x60 ,0xA0 ,0xE1 ,
		0xA8 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x20 ,0x50 ,0x90 ,0xE5 ,0x54 ,0x01 ,0x00 ,0xEB ,
		0x00 ,0x00 ,0x50 ,0xE3 ,0x21 ,0x00 ,0x00 ,0x1A ,
		0x22 ,0x00 ,0x00 ,0xEA ,0x01 ,0x00 ,0x45 ,0xE2 ,
		0x00 ,0x00 ,0x08 ,0xE0 ,0x00 ,0x40 ,0x45 ,0xE0 ,
		0x06 ,0x00 ,0x54 ,0xE1 ,0x06 ,0x40 ,0xA0 ,0x81
	};
	unsigned char arm7_writesram_a3[]=
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0x01 ,0x90 ,0xA0 ,0xE1 ,
		0x02 ,0x80 ,0xA0 ,0xE1 ,0x40 ,0x01 ,0x00 ,0xEB ,
		0x00 ,0x00 ,0x50 ,0xE3 ,0x23 ,0x00 ,0x00 ,0x0A ,
		0x94 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x70 ,0x90 ,0xE5 ,
		0x20 ,0x60 ,0x97 ,0xE5 ,0x01 ,0x40 ,0x46 ,0xE2 ,
		0x0A ,0xB0 ,0xA0 ,0xE3 ,0x00 ,0x00 ,0xA0 ,0xE3 ,
		0x00 ,0x00 ,0x8D ,0xE5 ,0x19 ,0x00 ,0x00 ,0xEA
	};

	unsigned char arm7_writesram_b[]=
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0x01 ,0x90 ,0xA0 ,0xE1 ,
		0x02 ,0x80 ,0xA0 ,0xE1 ,0xAC ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0x20 ,0x70 ,0x90 ,0xE5 ,
		0x21 ,0x01 ,0x00 ,0xEB ,0x01 ,0x50 ,0x47 ,0xE2 ,
		0x02 ,0xB0 ,0xA0 ,0xE3 ,0x00 ,0x40 ,0xA0 ,0xE3 ,
		0x1F ,0x00 ,0x00 ,0xEA ,0x05 ,0x00 ,0x0A ,0xE0 ,
		0x00 ,0x60 ,0x47 ,0xE0 ,0x08 ,0x00 ,0x56 ,0xE1
	};
	unsigned char arm7_writesram_b2[]=
	{
		0xF0 ,0x4F ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
		0x00 ,0xA0 ,0xA0 ,0xE1 ,0x01 ,0x90 ,0xA0 ,0xE1 ,
		0x02 ,0x80 ,0xA0 ,0xE1 ,0xA8 ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0xBC ,0x70 ,0xD0 ,0xE1 ,
		0xF5 ,0x00 ,0x00 ,0xEB ,0x01 ,0x50 ,0x47 ,0xE2 ,
		0x02 ,0xB0 ,0xA0 ,0xE3 ,0x00 ,0x40 ,0xA0 ,0xE3 ,
		0x1E ,0x00 ,0x00 ,0xEA ,0x05 ,0x00 ,0x0A ,0xE0 ,
		0x00 ,0x60 ,0x47 ,0xE0 ,0x08 ,0x00 ,0x56 ,0xE1
	};
	unsigned char arm7_writesram_b1[]=
	{
		0xF0 ,0x41 ,0x2D ,0xE9 ,0x00 ,0x80 ,0xA0 ,0xE1 ,
		0x01 ,0x70 ,0xA0 ,0xE1 ,0x02 ,0x60 ,0xA0 ,0xE1 ,
		0xA8 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x20 ,0x50 ,0x90 ,0xE5 ,0x22 ,0x01 ,0x00 ,0xEB ,
		0x00 ,0x00 ,0x50 ,0xE3 ,0x21 ,0x00 ,0x00 ,0x1A ,
		0x22 ,0x00 ,0x00 ,0xEA ,0x01 ,0x00 ,0x45 ,0xE2 ,
		0x00 ,0x00 ,0x08 ,0xE0 ,0x00 ,0x40 ,0x45 ,0xE0 ,
		0x06 ,0x00 ,0x54 ,0xE1 ,0x06 ,0x40 ,0xA0 ,0x81
	};

	unsigned char arm7_readsram[]=
	{
		0x70 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x60 ,0xA0 ,0xE1 ,
		0x01 ,0x50 ,0xA0 ,0xE1 ,0x02 ,0x40 ,0xA0 ,0xE1 ,
		0xF1 ,0x00 ,0x00 ,0xEB ,0x44 ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0x24 ,0x00 ,0x90 ,0xE5 ,
		0x01 ,0x00 ,0x80 ,0xE2 ,0x04 ,0x00 ,0x80 ,0xE0 ,
		0x29 ,0x01 ,0x00 ,0xEB ,0x06 ,0x00 ,0xA0 ,0xE1 ,
		0x03 ,0x10 ,0xA0 ,0xE3 ,0x4A ,0x00 ,0x00 ,0xEB ,
		0x00 ,0x00 ,0xA0 ,0xE3 ,0x05 ,0x10 ,0xA0 ,0xE1
	};

	unsigned char arm7_readsram1[]=
	{
		0x70 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x60 ,0xA0 ,0xE1 ,
		0x01 ,0x50 ,0xA0 ,0xE1 ,0x02 ,0x40 ,0xA0 ,0xE1 ,
		0xF3 ,0x00 ,0x00 ,0xEB ,0x00 ,0x00 ,0x50 ,0xE3 ,
		0x10 ,0x00 ,0x00 ,0x0A ,0x44 ,0x00 ,0x9F ,0xE5 ,
		0x00 ,0x00 ,0x90 ,0xE5 ,0x24 ,0x00 ,0x90 ,0xE5 ,
		0x01 ,0x00 ,0x80 ,0xE2 ,0x04 ,0x00 ,0x80 ,0xE0 ,
		0x35 ,0x01 ,0x00 ,0xEB ,0x06 ,0x00 ,0xA0 ,0xE1 ,
		0x03 ,0x10 ,0xA0 ,0xE3 ,0x4A ,0x00 ,0x00 ,0xEB
	};
	unsigned char arm7_readsram2[]=
	{
		0x70 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x60 ,0xA0 ,0xE1 ,
		0x01 ,0x50 ,0xA0 ,0xE1 ,0x02 ,0x40 ,0xA0 ,0xE1 ,
		0xC4 ,0x00 ,0x00 ,0xEB ,0x4A ,0x00 ,0x00 ,0xEB ,
		0x40 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5 ,
		0x01 ,0x00 ,0x80 ,0xE2 ,0x04 ,0x00 ,0x80 ,0xE0 ,
		0xFC ,0x00 ,0x00 ,0xEB ,0x06 ,0x00 ,0xA0 ,0xE1 ,
		0x03 ,0x10 ,0xA0 ,0xE3 ,0x18 ,0x00 ,0x00 ,0xEB ,
		0x00 ,0x00 ,0xA0 ,0xE3 ,0x05 ,0x10 ,0xA0 ,0xE1
	};
	unsigned char arm7_IQRModify[] = 
	{
		0x00 ,0x40 ,0x2D ,0xE9 ,0x01 ,0xC3 ,0xA0 ,0xE3 ,
		0x21 ,0xCE ,0x8C ,0xE2 ,0x08 ,0x10 ,0x1C ,0xE5 ,
		0x00 ,0x00 ,0x51 ,0xE3 ,0x00 ,0x80 ,0xBD ,0x08 ,
		0x06 ,0x00 ,0x9C ,0xE8 ,0x02 ,0x10 ,0x11 ,0xE0 ,
		0x00 ,0x80 ,0xBD ,0x08 ,0x01 ,0x30 ,0xA0 ,0xE3 ,
		0x00 ,0x00 ,0xA0 ,0xE3 ,0x13 ,0x20 ,0x11 ,0xE0 ,
		0x01 ,0x00 ,0x80 ,0x02 ,0xFC ,0xFF ,0xFF ,0x0A ,
		0x04 ,0x20 ,0x8C ,0xE5 ,0x08 ,0x10 ,0x9F ,0xE5
	};
	unsigned char arm7_readxy[]=
	{
		0x10 ,0x40 ,0x2D ,0xE9 ,0x00 ,0x40 ,0xA0 ,0xE3 ,
		0x02 ,0x09 ,0xA0 ,0xE3 ,0xEC ,0xFF ,0xFF ,0xEB ,
		0x20 ,0x00 ,0x9F ,0xE5 ,0xB0 ,0x10 ,0xD0 ,0xE1 ,
		0x80 ,0x00 ,0x11 ,0xE2 ,0x02 ,0x49 ,0xA0 ,0x13 ,
		0x0B ,0x00 ,0x01 ,0xE2 ,0x00 ,0x15 ,0x84 ,0xE1 ,
		0x0C ,0x00 ,0x9F ,0xE5 ,0xB0 ,0x10 ,0xC0 ,0xE1 ,
		0x10 ,0x40 ,0xBD ,0xE8 ,0x1E ,0xFF ,0x2F ,0xE1 ,
		0x36 ,0x01 ,0x00 ,0x04 ,0xA8 ,0xFF ,0x7F ,0x02
	};
	
	unsigned char arm9_IRQ_Modify[] =
	{
		0x30 ,0x01 ,0x00 ,0x04 
/*
		0x00 ,0x40 ,0x2D ,0xE9 ,0x01 ,0xC3 ,0xA0 ,0xE3 ,
		0x21 ,0xCE ,0x8C ,0xE2 ,0x08 ,0x10 ,0x1C ,0xE5 ,
		0x00 ,0x00 ,0x51 ,0xE3 ,0x00 ,0x80 ,0xBD ,0x08 ,
		0x06 ,0x00 ,0x9C ,0xE8 ,0x02 ,0x10 ,0x11 ,0xE0 ,
		0x00 ,0x80 ,0xBD ,0x08 ,0x02 ,0x31 ,0xA0 ,0xE3 ,
		0x11 ,0x0F ,0x6F ,0xE1 ,0x33 ,0x10 ,0xD1 ,0xE1 ,
		0xFC ,0xFF ,0xFF ,0x1A ,0x33 ,0x10 ,0xA0 ,0xE1 ,
		0x04 ,0x10 ,0x8C ,0xE5 ,0x1F ,0x00 ,0x70 ,0xE2
*/	};

	unsigned char arm9_setrom_op[] = 
	{
		0x70 ,0x30 ,0x9F ,0xE5 ,0x00 ,0x20 ,0x93 ,0xE5 ,
		0x02 ,0x21 ,0x12 ,0xE2 ,0xFC ,0xFF ,0xFF ,0x1A ,
		0x64 ,0x30 ,0x9F ,0xE5 ,0xC0 ,0xC0 ,0xA0 ,0xE3 ,
		0x60 ,0x20 ,0x9F ,0xE5 ,0x00 ,0xC0 ,0xC3 ,0xE5 ,
		0x20 ,0xCC ,0xA0 ,0xE1 ,0x58 ,0x30 ,0x9F ,0xE5 ,
		0x00 ,0xC0 ,0xC2 ,0xE5 ,0x20 ,0xC8 ,0xA0 ,0xE1 ,
		0x50 ,0x20 ,0x9F ,0xE5 ,0x00 ,0xC0 ,0xC3 ,0xE5 ,
		0x20 ,0xC4 ,0xA0 ,0xE1 ,0x48 ,0x30 ,0x9F ,0xE5
	};

	unsigned char arm7_GBA_union[] = 
	{
		0xB2 ,0x30 ,0xD2 ,0xE5 ,0x96 ,0x00 ,0x53 ,0xE3 ,
		0x04 ,0x00 ,0x00 ,0x1A ,0x94 ,0x00 ,0x9F ,0xE5 ,
		0xB0 ,0x10 ,0xD0 ,0xE1 ,0xBE ,0x0B ,0xD2 ,0xE1 ,
		0x00 ,0x00 ,0x51 ,0xE1 ,0x11 ,0x00 ,0x00 ,0x1A ,
		0x96 ,0x00 ,0x53 ,0xE3 ,0x05 ,0x00 ,0x00 ,0x0A ,
		0x78 ,0x00 ,0x9F ,0xE5 ,0xB0 ,0x10 ,0xD0 ,0xE1 ,
		0x7C ,0x00 ,0x9F ,0xE5 ,0xB0 ,0x00 ,0xD0 ,0xE1 ,
		0x00 ,0x00 ,0x51 ,0xE1 ,0x09 ,0x00 ,0x00 ,0x1A
	};

	DWORD codecardexist[]=
	{
		//ldr r0 , =0x27ff800
		//ldr r0 ,[r0]
		//bx  lr
		0xe59f0004,0xe5900000,0xe12fff1e,0x027ff800
	};

	DWORD arm7codeexist[]=
	{
		//ldrh r0,[pc,#0]
		//bx lr
		//dcd 00000fc2
		0xE1DF00B0,0xE12FFF1E,0x00000FC2
	};

	DWORD arm7Saver_entry2[] = 
	{
		0xE59F2010,	0xE59F3010,0xE3A01001,0xE5821000,0xE5831000,0xE12FFF1E,
		0x0380A280, 0x0380A280
	};

	DWORD codeaac[] = 
	{	//add lr,pc,#0x38
		//ldr pc,[pc]
		//dcd 0x2176e00	
		0xe28fe038,0xe51ff004,0x02176e00
	};
	WORD codeaacthumb[] = 
	{	//ldr r0,=0x2176e00
		//blx r0
		//b	  pc+0xxx	
		//dcd 0x2176e00	
		0x4801,0x4780,0xe017,0x0000,
		0x6e00,0x0217
	};
	const WORD thumbret0[] = 
	{// mov r0 , #0
	 // bx	lr
		0x2000,0x4770
	} ;
	const DWORD coderet0[] = 
	{// mov r0 , #0
	 // bx	lr
		0xe3a00000,0xe12fff1e
	} ;

#define RAM_AD 0xb8
#define ROM_AD 0xe0

	BOOL bSpecial ;
	BYTE *pCmp = NULL, *pfind = NULL ,*pfRead = NULL ,*pfWrite = NULL , *pfWrite_2 = NULL , *pmdy = NULL ,*parm7checkcard = NULL,*parm7readrom = NULL,*pfindthumb = NULL ;
	BYTE *pfReadThumb = NULL ,*pfWriteThumb = NULL,*pverify=NULL ,*pArm9readrom2 = NULL;
	BYTE *parm7erase=NULL,*parm7verify=NULL,*parm7writesva=NULL,*parm7writesvb=NULL,*parm7readsv=NULL,*parm7read512=NULL,*parm9cardexist=NULL ;
	DWORD arm9_start,arm9_copyto,arm9_exec,arm9_size ,arm7_start, r_start,r_in,r_sec , repl1,repl2,r_read,r_save;
	DWORD dw7erase,dw7verify,dw7writea,dw7writeb,dw7read,dw7read512,dw7readrom,arm7_exec,arm7_size;
	DWORD size , lenth , after_decmp , pad = 0 , setzero = 0 ,headoff = 0;
	CString outmsg ;
	BYTE bf ;
	//读出头，修改在这里修改即可
	BYTE saverspecial = GetSaverSpacial(pGame);
	bSpecial = QuerySpecial(pGame,headoff);

	lenth = sizeof(nds2);
	pmdy = new BYTE[lenth] ;
	memcpy(pmdy,nds2,lenth) ;
	//将nds文件的ARM9部分读出来
	arm9_start = *(DWORD*)(pGame+0x20);
	arm9_exec = *(DWORD*)(pGame+0x24);
	arm9_copyto = *(DWORD*)(pGame+0x28);
	arm9_size = *(DWORD*)(pGame+0x2C);
	arm7_start = *(DWORD*)(pGame+0x30);
	arm7_exec = *(DWORD*)(pGame+0x34);
	arm7_size =  *(DWORD*)(pGame+0x3C);
//寻找加密代码，看ARM9程序是否加密
	pfind = FindMotif(pGame,romsize,(BYTE*)compress,0x40);
	if(!pfind)
		pfind = FindMotif(pGame,romsize,(BYTE*)compress2,0x40);
	if(pfind)
	{//找到压缩码
		if(*(DWORD*)(pfind-8)!=0xe3500000)
		{
			pfind = NULL ;
			goto out1; 
		}
		else
		{
			pfind -= 8 ;
		}
		int			si ,a;
		DWORD		r0,r3,r2,r1,i,j,b ;
		DWORD		arm9_comp_end , arm9_comp_start ;
		DWORD		*pCodeSrc ;

		arm9_comp_end = arm9_start + arm9_size ;
		arm9_comp_start = pfind - pGame ;
		pCmp = new BYTE[0x280000] ;
		pCodeSrc = (DWORD*)pCmp ;
		memset(pCmp,0,0x280000);
		memcpy(pCmp,pGame,arm9_comp_end+0x100 );
		for(si=arm9_comp_start;si>0;si-=4)
		{
			if((pCodeSrc[si/4]&0xFF000000)==0xEB000000)
			{
				if(((pCodeSrc[si/4]&0xFFFFFF)*4+8+si)==arm9_comp_start)
					break;
			}
		}
		if(si>0) //si > 0 表示有压缩,直接进入解压缩代码
		{
			i = pCodeSrc[si/4-2]; //找出跳转前加载的参数的值
			if((i&0xFFFF0000)==0xe59f0000)
			{
				b = pCodeSrc[(si+(i&0xFFF))/4] ; //
				a = pCodeSrc[si/4-1] & 0xFFFF;  //所需数据的最后一位的偏移
				b =	b - arm9_copyto + arm9_start; //所需位置
				setzero = (b+a)/4 ;
				r0 = pCodeSrc[(b+a)/4] ; //-- 所得的位置-即解压缩最后一位开始解压放置的地址,世纪上就是大小(需要计算)
				//进行类似解压缩的数据处理
				if(r0!=0)// r0 > 0 表示有压缩,直接进入解压缩代码
				{
					a = r0 - arm9_copyto + arm9_start;
					r2 = pCodeSrc[a/4-1] ;	//读出的值为往后解压需要的额外的空间
					r1 = pCodeSrc[a/4-2] ;
					r2 = r0 + r2 ;// --这里就是得到的总共的地址.
					//看2MByte空间是否足够,如果不够,需要重新分配
					after_decmp = (r2-arm9_copyto+ arm9_start) ;
					if(after_decmp>0x280000)
					{
						delete pCmp ;
						pCmp = new BYTE[after_decmp+0x100] ;
						memset(pCmp,0,after_decmp+0x100);
						memcmp(pCmp,pGame,arm9_size+arm9_start+0x100);
						pCodeSrc = (DWORD*)pCmp ;
					}
					r3 = r0 - (r1>>0x18);
					r1 = r1 & 0xFFFFFF ;
					r1 = r0 - r1 ; 
					//确定第二个缓存大小
					//还原　r0,r1,r3,
					r2 = r2 - arm9_copyto + arm9_start; //目标所指的最后一个地址
					r1 = r1 - arm9_copyto + arm9_start;
					r3 = r3 - arm9_copyto + arm9_start;
					while(r3>r1)
					{
						r3 -- ;
						b = pCmp[r3] ;
						si = 8 ;
						while((si--))
						{
							if(b&0x80)
							{
								r3--;
								a = pCmp[r3] ;
								r3--;
								i = pCmp[r3] ;
								i = i + (a<<8) ;
								i = i & 0xFFF ;
								i = i + 2 ;
								a = a + 0x20 ;
								do
								{
									j =  pCmp[r2+i] ;
									r2 -- ;
									pCmp[r2] = j ;
									a = a - 0x10 ;
								}while(a>=0) ;
								b = b << 1 ;
							}
							else
							{
								r3 -- ;
								r2 -- ;
								pCmp[r2] = pCmp[r3] ;
								b = b << 1 ;
							}
							if(r3<=r1)
								goto out1 ;
						}
					}
				}
				else
				{
					delete pCmp ;
					pCmp = NULL ;
				}
			}
out1	:
			b = 1 ; //结束
		}
	}		
	if(pCmp)
	{
#ifdef _DEBUG
	CFile f1 ;
	f1.Open("c:\\tp.bin",CFile::modeCreate|CFile::modeWrite);
	f1.Write(pCmp,0x280000);
	f1.Close();
#endif
		pad = after_decmp - (arm9_size + arm9_start) ;
		pad = ((pad + 0x7FFF)/0x8000 )*0x8000 ;
		pfRead = new BYTE[romsize + pad] ;
		memset(pfRead,0,pad);
		//拷贝游戏代码,然后再将解压后的游戏代码放置前方覆盖后面的压缩码
		memcpy(pfRead+pad,pGame,romsize) ;
		memcpy(pfRead,pCmp,after_decmp) ;
		//将游戏大小改变,并改变指针
		romsize = romsize + pad ;
		delete pGame ;
		pGame = pfRead ;
		((DWORD*)pGame)[setzero] = 0 ; //设置后不再压缩
		delete pCmp ; pCmp = NULL ;
		//设置压缩解除标志
		ModifyNDSHeader(pGame,after_decmp-arm9_start,pad);
		rompage = 0 ;
		//*(DWORD*)(pmdy+0x210) = 0xFF00FF00; //标志
		//*(DWORD*)(pmdy+0x214) = after_decmp; //大小
		//*(DWORD*)(pmdy+0x218) = arm7_start+pad; //大小
		//rompage += (pad/0x8000) ;
	}
	size = arm7_start + (*(DWORD*)(pGame+0x3C)) + pad;
//寻找代码，此为ARm9读取卡带的代码
	pfind = FindMotif(pGame,size,arm9read,0x40);
	bf = 0 ;
	if(!pfind)
	{
		pfind = FindMotif(pGame,size,arm9read3,0x40);
	}
	if(!pfind)
	{
		pfind = FindMotif(pGame,size,arm9read4,0x38,0x28);
		bf = 1 ;
	}
	if(!pfind)
	{
		pfind = FindMotif(pGame,size,arm9read2,0x40);
		bf = 2 ;
	}
	if(!pfind)
	{
		pfind = FindMotif(pGame,size,arm9read5,0x40);
		bf = 3 ;
	}
	if(!pfind)
	{
		pfind = FindMotif(pGame,size,arm9read6,0x40);
		bf = 4 ;
	}
	if(!pfind)
	{
		pfindthumb = FindMotif(pGame,size,arm9read_thumb1,0x40);
		if(!pfindthumb)
			pfindthumb = FindMotif(pGame,size,arm9read_thumb2,0x40);
		if(!pfindthumb)
			pfindthumb = FindMotif(pGame,size,arm9read_thumb3,0x40);
	}

	pArm9readrom2 = FindMotif(pGame,size,arm9anotherRead,0x40,0x28);
	if(!pArm9readrom2)
		pArm9readrom2 = FindMotif(pGame,size,arm9anotherRead2,0x40,0x28);

//寻找Arm7读代码
	parm7readrom = FindMotif(pGame,size,arm7read,0x40);
//寻找arm7中的代码
	if(saverspecial!=2)
	{
		DWORD identify = 0 , identify2 = 0 ;
		parm9cardexist = FindMotif(pGame,size,arm9_cardexist,0x40,0x10);
		if(!parm9cardexist)
		{
			parm9cardexist = FindMotif(pGame,size,arm9_cardexist_1,0x40,0x10);
		}
		if(!parm9cardexist)
		{
			parm9cardexist = FindMotif(pGame,size,arm9_cardexist_2,0x40,0xc);
		}
		if(parm9cardexist)
		{
			memcpy(parm9cardexist,codecardexist,sizeof(codecardexist));		
		}
		if(!parm9cardexist)
		{
		//寻找amr9 thumb cardexist
		BYTE *parm9thumbexist ;
			const BYTE arm9_thumext[]={0x01 ,0x48 ,0x00 ,0x68 ,0x70 ,0x47 ,0x00 ,0x00 ,0x00 ,0xF8 ,0x7F ,0x02};
			parm9thumbexist = FindMotif(pGame,size,arm9_thumbcardexist,0x40,0x8);
			if(!parm9thumbexist)
				parm9thumbexist = FindMotif(pGame,size,arm9_thumbcardexist2,0x40);		
			if(parm9thumbexist)
			{
				memcpy(parm9thumbexist,arm9_thumext,sizeof(arm9_thumext));					
			}
		}
//寻找arm7中的代码

		parm7checkcard  = FindMotif(pGame,size,arm7_checkcard,0x40,0x24);
		if(parm7checkcard)
		{
			BYTE anotercheck[] = 
			{
				0x00 ,0x40 ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
				0x2E ,0x03 ,0xA0 ,0xE3 ,0x00 ,0x10 ,0xA0 ,0xE3 ,
				0x14 ,0x00 ,0x00 ,0xEB ,0x3C ,0x00 ,0x9F ,0xE5 ,
				0x00 ,0x00 ,0x90 ,0xE5 ,0x07 ,0x04 ,0xC0 ,0xE3 ,
				0xA7 ,0x14 ,0x80 ,0xE3 ,0x02 ,0x0A ,0xA0 ,0xE3 ,
				0x00 ,0x00 ,0x60 ,0xE2 ,0x00 ,0x00 ,0x01 ,0xE0 ,
				0x24 ,0x10 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x81 ,0xE5 ,
				0x00 ,0x00 ,0x91 ,0xE5 ,0x02 ,0x05 ,0x10 ,0xE2
			};
			BYTE anotercheck2[] = 
			{
				0x00 ,0x40 ,0x2D ,0xE9 ,0x04 ,0xD0 ,0x4D ,0xE2 ,
				0x2E ,0x03 ,0xA0 ,0xE3 ,0x00 ,0x10 ,0xA0 ,0xE3 ,
				0x4E ,0x00 ,0x00 ,0xEB ,0x30 ,0x00 ,0x9F ,0xE5 ,
				0x00 ,0x00 ,0x90 ,0xE5 ,0x07 ,0x04 ,0xC0 ,0xE3 ,
				0xA7 ,0x04 ,0x80 ,0xE3 ,0x24 ,0x10 ,0x9F ,0xE5 ,
				0x00 ,0x00 ,0x81 ,0xE5 ,0x00 ,0x00 ,0x91 ,0xE5 ,
				0x02 ,0x05 ,0x10 ,0xE2 ,0xFC ,0xFF ,0xFF ,0x0A ,
				0x14 ,0x00 ,0x9F ,0xE5 ,0x00 ,0x00 ,0x90 ,0xE5
			};
			BYTE *pa7chek2 ;
			DWORD *pw,k ;
			int kf ;
			pa7chek2 =  FindMotif(pGame,size,anotercheck,0x40,0x10);
			if(!pa7chek2)
				pa7chek2 =  FindMotif(pGame,size,anotercheck2,0x40,0x10);
			if(pa7chek2)
			{//向上搜寻
				pw = (DWORD*)pa7chek2 ;
				for(k=0;k<0x200;k++)
				{
					if(*(pw-k) == 0xEB000000 + k - 2 )
						break;
				}
			}
			int offset = (__int16)(*(DWORD*)(parm7checkcard + 0x24)&0xFFFF);
			parm7checkcard += 0x24 + 8;
			parm7checkcard += offset*4 ;
			//应该去搜索位置
			if((*(DWORD*)(parm7checkcard + 0x4BC) == 0xe5991000 )&& (*(DWORD*)(parm7checkcard + 0x4C0) == 0xe5810008 ))
			{
				memcpy(parm7checkcard,codecardexist,sizeof(codecardexist));	
				*(DWORD*)(parm7checkcard + 0x4B8) =  0xEC000000 -  0x4B8/4 - 2 ;
				if(pa7chek2&&(k<0x200))
				{
					kf = parm7checkcard - (BYTE*)(pw-k) - 8 ;
					if(kf >0 )
						*(pw-k) = 0xeb000000 + kf/4 ;
					else
						*(pw-k) = 0xec000000 + kf/4 ;
				}
			}
			else if((*(DWORD*)(parm7checkcard + 0x4B4) == 0xe5941000 )&& (*(DWORD*)(parm7checkcard + 0x4b8) == 0xe5810008 ))
			{
				memcpy(parm7checkcard,codecardexist,sizeof(codecardexist));	
				//*(DWORD*)(parm7checkcard + 0x4B0) = 0xEBFFFED2 ;
				*(DWORD*)(parm7checkcard + 0x4B0) = 0xEC000000 -  0x4B0/4 - 2;
				if(pa7chek2&&(k<0x200))
				{
					kf = parm7checkcard - (BYTE*)(pw-k) - 8 ;
					if(kf >0 )
						*(pw-k) = 0xeb000000 + kf/4 ;
					else
						*(pw-k) = 0xec000000 + kf/4 ;

				}
			}
			else if((*(DWORD*)(parm7checkcard + 0x2BC) == 0xe5991000 )&& (*(DWORD*)(parm7checkcard + 0x2C0) == 0xe5810008 ))
			{
				memcpy(parm7checkcard,codecardexist,sizeof(codecardexist));	
				*(DWORD*)(parm7checkcard + 0x2B8) = 0xEBFFFf50 ;
				if(pa7chek2&&(k<0x200))
				{
					kf = parm7checkcard - (BYTE*)(pw-k) - 8 ;
					if(kf >0 )
						*(pw-k) = 0xeb000000 + kf/4 ;
					else
						*(pw-k) = 0xec000000 + kf/4 ;
				}
			}
			else if((*(DWORD*)(parm7checkcard + 0x4A0) == 0xe5941000 )&& (*(DWORD*)(parm7checkcard + 0x4A4) == 0xe5810008 ))
			{
				memcpy(parm7checkcard,codecardexist,sizeof(codecardexist));	
				*(DWORD*)(parm7checkcard + 0x49c) = 0xEC000000 -  0x49c/4 - 2;

			}
			else
			{
				if(pa7chek2)
				{//向下搜寻
					pw = (DWORD*)pa7chek2 ;
					for(k=0;k<0x200;k++)
					{
						if(*(pw+k) == 0xEC000000 - k - 2 )
							break;
					}
				}
				memcpy(parm7checkcard,codecardexist,sizeof(codecardexist));	
				if(pa7chek2&&(k<0x200))
				{
					kf = parm7checkcard - (BYTE*)(pw+k) - 8 ;
					if(kf >0 )
						*(pw+k) = 0xeb000000 + kf/4 ;
					else
						*(pw+k) = 0xec000000 + kf/4 ;
				}
			}
		}

	//寻找擦除代码
		parm7erase = FindMotif(pGame,size,arm7_erasesram,0x40,0x20);
		if(!parm7erase)
		{
			parm7erase = FindMotif(pGame,size,arm7_erasesram_a,0x40,0x20);
		}
		if(!parm7erase)
		{
			parm7erase = FindMotif(pGame,size,arm7_erasesram1,0x40,0x28);
		}
		if(!parm7erase)
		{
			parm7erase = FindMotif(pGame,size,arm7_erasesram1,0x14,0x8);
			if(parm7erase)
			{
				if(memcmp(parm7erase+0x16,arm7_erasesram1+0x16,18))
					parm7erase = NULL ;
			}
		}
		if(!parm7erase)
		{
			parm7erase =  FindMotif(pGame,size,arm7_erasesram2,0x30);
		}
		if(!parm7erase)
		{
			parm7erase =  FindMotif(pGame,size,arm7_erase3,0x40);		
		}
		if(!parm7erase)
		{
			parm7erase =  FindMotif(pGame,size,arm7_erasesram4,0x40);		
		}

		parm7verify = FindMotif(pGame,size,arm7_verifysram,0x40,0x34);
		if(!parm7verify)
			parm7verify = FindMotif(pGame,size,arm7_verifysram,0x34,0x10);
		if(parm7verify)
		{
			int off = ((*(DWORD*)(parm7verify+24))&0xFFFF) + 0x20;
			int save = (*(DWORD*)(parm7verify+28)) & 0xFF ;
			*((DWORD*)arm7_verify_ez3 + 6) &= 0xFFFFFF00 ;
			*((DWORD*)arm7_verify_ez3 + 6) += save ;
			identify = *(DWORD*)(parm7verify + off) ;
			off = ((*(DWORD*)(parm7verify+40))&0xFFFF) + 0x74;
			identify2 = *(DWORD*)(parm7verify + off) ;
		}
		if(!parm7verify)
		{
			parm7verify = FindMotif(pGame,size,arm7_verifysram1,0x3c,0x10);
			if(parm7verify)
			{
				int off = ((*(DWORD*)(parm7verify+32))&0xFFFF) + 0x28;
				int save = (*(DWORD*)(parm7verify+36)) & 0xFF ;
				*((DWORD*)arm7_verify_ez3 + 6) &= 0xFFFFFF00 ;
				*((DWORD*)arm7_verify_ez3 + 6) += save ;
				identify = *(DWORD*)(parm7verify + off) ;
				off = ((*(DWORD*)(parm7verify+40))&0xFFFF) + 0x30;
				identify2 = *(DWORD*)(parm7verify + off) ;
			}
		}
		if(!parm7verify)
		{
			parm7verify = FindMotif(pGame,size,arm7_verifysram2,0x40);
			if(parm7verify)
			{
				int off = ((*(DWORD*)(parm7verify+24))&0xFFFF) + 0x20;
				int save = (*(DWORD*)(parm7verify+28)) & 0xFF ;
				*((DWORD*)arm7_verify_ez3 + 6) &= 0xFFFFFF00 ;
				*((DWORD*)arm7_verify_ez3 + 6) += save ;
				identify = *(DWORD*)(parm7verify + off) ;
				off = ((*(DWORD*)(parm7verify+0x64))&0xFFFF) + 0x6C ;
				identify2 = *(DWORD*)(parm7verify + off) ;
			}

		}
		if(!parm7verify)
		{
			parm7verify = FindMotif(pGame,size,ar7_verifysram3,0x40);
			if(parm7verify)
			{
				int off = ((*(DWORD*)(parm7verify+32))&0xFFFF) + 40;
				int save = (*(DWORD*)(parm7verify+48)) & 0xFF ;
				*((DWORD*)arm7_verify_ez3 + 6) &= 0xFFFFFF00 ;
				*((DWORD*)arm7_verify_ez3 + 6) += save ;
				identify = *(DWORD*)(parm7verify + off) ;
				off = ((*(DWORD*)(parm7verify+44))&0xFFFF) + 52 ;
				identify2 = *(DWORD*)(parm7verify + off) ;
			}
		}

		parm7writesva = FindMotif(pGame,size,arm7_writesram_a,0x40,0x20);
		if(!parm7writesva)
			parm7writesva = FindMotif(pGame,size,arm7_writesram_a1,0x40,0x1c);
		if(!parm7writesva)
			parm7writesva = FindMotif(pGame,size,arm7_writesram_a2,0x40,0x20);
		if(!parm7writesva)
			parm7writesva = FindMotif(pGame,size,arm7_writesram_a3,0x40);

		if(parm7writesva)
		{
			parm7writesvb = FindMotif(parm7writesva+0x40,0x1000,arm7_writesram_b,0x40,0x20);
			if(!parm7writesvb)
				parm7writesvb = FindMotif(parm7writesva+0x40,0x1000,arm7_writesram_b1,0x40,0x1C);
			if(!parm7writesvb)
				parm7writesvb = FindMotif(parm7writesva+0x40,0x1000,arm7_writesram_b2,0x40,0x20);
			if(!parm7writesvb)
				parm7writesvb = FindMotif(parm7writesva+0x40,0x1000,arm7_writesram_a3,0x30,0x14);
		}

		parm7readsv = FindMotif(pGame,size,arm7_readsram,0x40,0x28);
		if(!parm7readsv)
			parm7readsv = FindMotif(pGame+arm7_start,arm7_size,arm7_readsram,0x24,0x10);
		if(!parm7readsv)
			parm7readsv = FindMotif(pGame,size,arm7_readsram1,0x30,0x10);
		if(!parm7readsv)
			parm7readsv = FindMotif(pGame,size,arm7_readsram2,0x40,0x10);

		parm7read512 = FindMotif(pGame,size,arm7_readrom512,20);
		if(parm7read512)
		{
			if(memcmp(parm7read512+0x30,arm7_readrom512+0x30,0x10))
				parm7read512 = NULL ;
		}
		else
			parm7read512 = FindMotif(pGame,size,arm7_readrom512_1,0x30) ;

		dw7erase = parm7erase - pGame;
		dw7verify = parm7verify - pGame;
		dw7writea = parm7writesva - pGame ;
		dw7writeb = parm7writesvb - pGame ;
		dw7read = parm7readsv - pGame ;
		dw7read512 = parm7read512 - pGame ;
		if(parm7erase&&parm7verify)
		{
			memcpy(parm7erase,arm7_erase_ez3,sizeof(arm7_erase_ez3));
			memcpy(parm7verify,arm7_verify_ez3,sizeof(arm7_verify_ez3));
			*((DWORD*)(parm7erase+0xc)) = 0xEB000000 + (parm7verify - parm7erase )/4 + 4 ;
			*((DWORD*)(parm7verify+0x74)) = rampage ;
			*((DWORD*)(parm7verify+0x78)) = identify ;
			if(identify2)
				*((DWORD*)(parm7verify+0x7C)) = identify2 ;
			else
				*((DWORD*)(parm7verify+28)) = 0 ;
		}
		if(parm7writesva && parm7writesvb &&  parm7readsv)
		{
			memcpy(parm7writesva,arm7_writesaver_ez3,sizeof(arm7_writesaver_ez3));
			memcpy(parm7writesvb,arm7_writesaver_ez3,sizeof(arm7_writesaver_ez3));
			memcpy(parm7readsv,arm7_readsaver_ez3,sizeof(arm7_readsaver_ez3));
			*((DWORD*)(parm7writesva+0xB4)) =  rampage ;
			*((DWORD*)(parm7writesvb+0xB4)) = rampage ;
			//*((DWORD*)(parm7readsv+0xB4)) = rampage ;
			//后续，跳转到writersaver2的setrampage
			*((DWORD*)(parm7readsv+0x8))  = 0xEC000000 - ((parm7readsv-parm7writesvb+8)/4 - 6) + 17  ;
			if((*((DWORD*)(parm7readsv+0x70+0x90))&0xFFFF0000)==0xe5800000)
			{
				*((DWORD*)(parm7readsv+0x70))  = 0xEA00001F ;
				*((DWORD*)(parm7readsv+0x70+0x94)) = 0xE12FFF1E ;
			}
			else if((*((DWORD*)(parm7readsv+0x70+0x8C))&0xFFFF0000)==0xe5800000)
			{
				*((DWORD*)(parm7readsv+0x70))  = 0xEA00001F ;
				*((DWORD*)(parm7readsv+0x70+0x90)) = 0xE12FFF1E ;
			}
			else if((*((DWORD*)(parm7readsv+0x140))&0xFFFF0000)==0xe5800000)
			{
				*((DWORD*)(parm7readsv+0x68))  = 0xEA000032 ;
				*((DWORD*)(parm7readsv+0x144)) = 0xE12FFF1E ;
			}
		//memcpy(parm7readsv+0x70,arm7Saver_entry2,sizeof(arm7Saver_entry2));
			
		}

		if(parm7read512)
		{
			memcpy(parm7read512,arm7_readrom512_ez3,sizeof(arm7_readrom512_ez3));
			*((DWORD*)(parm7read512+0xc0)) =  rompage*0x8000 ;
			*(DWORD*)(pGame+0xBF4) =  parm7read512+0xc0 - pGame ; //需要在Ndsloader中修改的地方
		}
	}
//寻找ARm9存档读代码
	pfRead = FindMotif(pGame,size,ReadSaver_550,0x40,0x20);
	if(!pfRead)
		pfRead = FindMotif(pGame,size,ReadSaver_550_2,0x40,0x1c);
	if(pfRead)
	{
		if(*((DWORD*)(pfRead-0x38)) == 0xe92d47f0)
			pfRead -= 0x38 ;
		else if(*((DWORD*)(pfRead-0x40)) == 0xe92d47f0)
			pfRead -= 0x40 ;
		else
			pfRead = 0 ;
		r_read = pfRead - pGame ;
		r_read = r_read - arm9_start + arm9_copyto ;
	}
	else
	{
		pfReadThumb = FindMotif(pGame,size,ReadSaver_550thumb,0x40,16);
		if(!pfReadThumb)
		{
			pfReadThumb = FindMotif(pGame,size,ReadSaver_550thumb_2,0x40,16);
		}
		if(!pfReadThumb)
		{
			pfReadThumb = FindMotif(pGame,size,ReadSaver_550thumb_3,0x40,16);
		}
		if(!pfReadThumb)
		{
			pfReadThumb = FindMotif(pGame,size,ReadSaver_550thumb_4,0x40,16);
		}
		r_read = 0 ;
	}
//寻找ARm9存档写代码
	int r_save2 ;
	pfWrite = FindMotif(pGame,size,WriteSaver_47c,0x40,0x20);
	if(!pfWrite)
		pfWrite = FindMotif(pGame,size,WriteSaver_47c_2,0x40,0x1c);
	if(pfWrite)
	{
		if(*((DWORD*)(pfWrite-0x38)) != 0xe92d47f0)
			pfWrite = 0 ;
		else
			pfWrite -= 0x38 ;
		r_save = pfWrite - pGame ;
		r_save = r_save - arm9_start + arm9_copyto ;

		//找第二个存档
		pfWrite_2 = FindMotif(pfWrite+0x50,0x1000,WriteSaver_47c,0x40,0x20);
		if(!pfWrite_2)
			pfWrite_2 = FindMotif(pfWrite+0x50,0x1000,WriteSaver_47c_2,0x40,0x1c);
		if(pfWrite_2)
		{
			if(*((DWORD*)(pfWrite_2-0x38)) != 0xe92d47f0)
				pfWrite_2 = 0 ;
			else
				pfWrite_2 -= 0x38 ;
			r_save2 = pfWrite_2 - pGame ;
			r_save2 = r_save - arm9_start + arm9_copyto ;
		}
	}
	else
	{
		pfWriteThumb = FindMotif(pGame,size,WriteSaver_47cthumb,0x40,16);
		if(!pfWriteThumb)
			pfWriteThumb = FindMotif(pGame,size,WriteSaver_47cthumb_2,0x40,16);
		if(!pfWriteThumb)
			pfWriteThumb = FindMotif(pGame,size,WriteSaver_47cthumb_3,0x40,16);
		if(!pfWriteThumb)
			pfWriteThumb = FindMotif(pGame,size,WriteSaver_47cthumb_4,0x40,16);
		r_save = 0 ;
	}

	if(pfind)
	{//拷贝读EZFlash代码到游戏中
		int aacoff ;
		r_start = pfind - pGame ;
		if(bf==2)
		{
			r_in = r_start +0x5C ;
			r_sec = r_start+0x11c ;
			codeaac[0] = 0xe28fe040 ;

		}
		else if(bf==1)
		{
			r_in = r_start +0x58 ;
			r_sec = r_start+0xF8 ;
			codeaac[0] = 0xe28fe038 ;
		}
		else if(bf ==3)
		{
			r_in = r_start +0x58 ;
			codeaac[0] = 0xe28fe04C ;
		}
		else if(bf ==4)
		{//为4的情况比较特殊，trydma在readcard之前
			//mov   r12,r8
			//mov   r8,r5
			//add lr,pc,#0x3C
			//ldr pc,[pc]
			//dcd 0x2176e00	
			//mov	r8,r12
			r_in = r_start + 0x44 ;
			r_sec = r_start - 0x160 ;
			codeaac[0] = 0xe28fe030 ;
		}
		else
		{
			r_in = r_start +0x58 ;
			r_sec = r_start+0x100 ;
			codeaac[0] = 0xe28fe038 ;
		}
		// repl1,reple2 为替换的在NDS上的位置
		//aac 的位置 - repl1

		//if(!parm7erase||bSpecial)
		if(bf==3)
		{
			//放在头部的位置
			codeaac[2] = arm9_copyto + 0xC ;
			//AAC
			memcpy((pGame+r_in),codeaac,12); //readcar需要修改
			//copy read EZflash
			*(DWORD*)&(arm9_aac[ROM_AD]) = rompage*0x8000 ; 
			//修改trydma
			r_sec = r_start+0x2a4 ;
			memcpy((pGame+r_sec),coderet0,8);
			//
			r_sec =  arm9_start+0xC ;
			*(DWORD*)(pGame+r_sec) =  0xE1A01000 ;//mov r1,r0
			*(DWORD*)(pGame+r_sec+4) = 0xE1A08007 ;//mov r8,r7
			//修改
			memcpy((pGame+arm9_start+0xC+8),arm9_aac,sizeof(arm9_aac));
			*(DWORD*)(pGame+0xBF0) =  arm9_start+0xC+8+ROM_AD ; //需要在Ndsloader中修改的地方
		}
		else if(!bSpecial)
		{
			//放在cardi_TryDMA中
			repl1 = r_in - arm9_start + arm9_copyto ; 
			//B54 的位置 - repl2
			repl2 = r_sec - arm9_start + arm9_copyto ;
			codeaac[2] = repl2 + 8 ;
			//计算完毕，准备拷贝代码
			//AAC
			if(bf==4)
			{
				*(DWORD*)(pGame+r_in) = 0xE1A0C008;
				*(DWORD*)(pGame+r_in+4) = 0xE1A08005;
				*(DWORD*)(pGame+r_in+8) = 0xE1A01002;
				memcpy((pGame+r_in+0xc),codeaac,12);
				*(DWORD*)(pGame+r_in+0x44) = 0xE1A0800C;
			}
			else
				memcpy((pGame+r_in),codeaac,12);
			//b54
			memcpy((pGame+r_sec),coderet0,8);
			//copy read EZflash
			*(DWORD*)&(arm9_aac[ROM_AD]) = rompage*0x8000 ;
			memcpy((pGame+r_sec+8),arm9_aac,sizeof(arm9_aac));
			*(DWORD*)(pGame+0xBF0) =  r_sec+8+ROM_AD ; //需要在Ndsloader中修改的地方
		}
		else
		{//放在头部的位置
			codeaac[2] = arm9_copyto + 0xC + headoff;
			//AAC
			if(bf==4)
			{
				*(DWORD*)(pGame+r_in) = 0xE1A0C008;
				*(DWORD*)(pGame+r_in+4) = 0xE1A08005;
				*(DWORD*)(pGame+r_in+8) = 0xE1A01002;
				memcpy((pGame+r_in+0xc),codeaac,12);
				*(DWORD*)(pGame+r_in+0x44) = 0xE1A0800C;
			}
			else
				memcpy((pGame+r_in),codeaac,12); //readcar需要修改
			//copy read EZflash
			*(DWORD*)&(arm9_aac[ROM_AD]) = rompage*0x8000 ; 
			int k ;
			for(k = 0 ;k<0x200;k++)
			{
				if(((*(DWORD*)(pfind - k*4))&0xFF000000) == 0xEB000000)
				{
					int skip ;
					if(bf == 2) skip = 0x11c ;
					else if(bf ==1) skip = 0xf8 ;
					else skip = 0x100 ;
					DWORD off =	*(DWORD*)(pfind - k*4) &0xFFFFFF  ;
					if((off*4+8)== (k*4 + skip))
					{
						off = *(DWORD*)(pfind - k*4 + 8) ;
						off = off&0xFFFFFF ;
						*(DWORD*)(pfind - k*4) = 0xE3a00000;
						*(DWORD*)(pfind - k*4 + off*4 + 0x10 ) = 0xE3a00000;
						break;
					}
				}
			}
			if((k<0x200)||(bf==4))
			{
				memcpy((pGame+arm9_start+0xC+headoff),arm9_aac,sizeof(arm9_aac));
				aacoff = arm9_start+0xC+headoff;
				*(DWORD*)(pGame+0xBF0) =  arm9_start+0xC+headoff+ROM_AD ; //需要在Ndsloader中修改的地方
			}
		}
		if(pArm9readrom2)
		{
			//猜测不能和正式读混于一起，另外拷贝读代码,拷贝至,后执行代码区
			//memcpy((pGame+arm9_start+0xC+sizeof(arm9_aac)-1),arm9_aac,sizeof(arm9_aac));
			((DWORD*)arm9_readcard2)[0x84/4] = codeaac[2];//+ sizeof(arm9_aac) - 1 ;
			memcpy(pArm9readrom2,arm9_readcard2,sizeof(arm9_readcard2));
		}
		if((saverspecial!=1))
		{
			//replace 0x4000204
			BYTE *p , *f;
			DWORD ss ;
			BYTE r204[] = {0x4,0x2,0,4};
			f = pGame ;
			ss = size ;
			do
			{
				p = FindMotif(f,ss,r204,0x4);
				if(!p)
					continue ;
				if(!((DWORD)p&0x3))
				{
					if(((*(DWORD*)(p-0xc) == 0xe3800080)||(*(DWORD*)(p-0xc) == 0xe3C00080))&&b_gba)
						*(DWORD*)p = 0x04000204 ;
					else
						*(DWORD*)p = 0x08000204 ;
				}
				ss -= (p+4 - f) ;
				f = p + 4 ;
			}
			while(p);
		}

	}
	else
	{
		if(pfindthumb)
		{//放在trydma
			int aa ;
			int bb =0;
			if(!bSpecial)
			{
				if(*(DWORD*)(pfindthumb-0x7e)==0xf89ff000)
				{
					*(WORD*)(pfindthumb-0x7e) = 0x2000;
					*(WORD*)(pfindthumb-0x7c) = 0x2000;
					*(WORD*)(pfindthumb-0x64) = 0x2000;
					bb = 1 ;
				}
				else if(*(DWORD*)(pfindthumb-0xce)==0xf8c7f000)
				{
					*(WORD*)(pfindthumb-0xce) = 0x2000;
					*(WORD*)(pfindthumb-0xcc) = 0x2000;
					*(WORD*)(pfindthumb-0xb4) = 0x2000;
					bb = 1 ;
				}
				else if(*(DWORD*)(pfindthumb-0x138)==0xf8fcf000)
				{
					*(WORD*)(pfindthumb-0x138) = 0x2000;
					*(WORD*)(pfindthumb-0x136) = 0x2000;
					*(WORD*)(pfindthumb-0x11e) = 0x2000;
						bb = 1 ;
				}
				else if(*(DWORD*)(pfindthumb-0xbe)==0xf8BBF000)
				{
					*(WORD*)(pfindthumb-0xbe) = 0x2000;
					*(WORD*)(pfindthumb-0xbc) = 0x2000;
					*(WORD*)(pfindthumb-0xa8) = 0x2000;
						bb = 1 ;
				}
				r_start = pfindthumb - pGame ;
				r_in = r_start +0x36 ;
				r_sec = r_start+0xC4 ;
				repl1 = r_in - arm9_start + arm9_copyto ;			
				repl2 = r_sec - arm9_start + arm9_copyto ;
				if(bb)
					aa = repl2 ;
				else
				{
					*(DWORD*)(pfindthumb+0xC4) = 0x47702000;
					aa = repl2 + 4 ;
				}
				if(r_in%4)
				{
					codeaacthumb[3] = aa&0xFFFF ;
					codeaacthumb[4] =  (aa>>16)&0xFFFF;
				}
				else
				{
					codeaacthumb[4] = aa&0xFFFF ;
					codeaacthumb[5] =  (aa>>16)&0xFFFF;
				}
				//AAC
				memcpy((pGame+r_in),codeaacthumb,12);
				//exec aac
				//copy read EZflash
				*(DWORD*)&(arm9_thumb[ROM_AD]) = rompage*0x8000 ;
				memcpy((pGame+(aa+arm9_start-arm9_copyto)),arm9_thumb,sizeof(arm9_thumb));
				*(DWORD*)(pGame+0xBF0) =  (aa+arm9_start-arm9_copyto)+ROM_AD ; //需要在Ndsloader中修改的地方
			}
			else
			{//放在头
				if(*(DWORD*)(pfindthumb-0x7e)==0xf89ff000)
				{
					*(WORD*)(pfindthumb-0x7e) = 0x2000;
					*(WORD*)(pfindthumb-0x7c) = 0x2000;
					*(WORD*)(pfindthumb-0x64) = 0x2000;
				}
				else if(*(DWORD*)(pfindthumb-0xce)==0xf8c7f000)
				{
					*(WORD*)(pfindthumb-0xce) = 0x2000;
					*(WORD*)(pfindthumb-0xcc) = 0x2000;
					*(WORD*)(pfindthumb-0xb4) = 0x2000;
				}
				else if(*(DWORD*)(pfindthumb-0x138)==0xf8fcf000)
				{
					*(WORD*)(pfindthumb-0x138) = 0x2000;
					*(WORD*)(pfindthumb-0x136) = 0x2000;
					*(WORD*)(pfindthumb-0x11e) = 0x2000;
				}
				r_start = pfindthumb - pGame ;
				r_in = r_start +0x36 ;
				r_sec = 0x400c + headoff ;
				repl1 = r_in - arm9_start + arm9_copyto ;			
				repl2 = r_sec - arm9_start + arm9_copyto ;
				aa = repl2 ;
				if(r_in%4)
				{
					codeaacthumb[3] = aa&0xFFFF ;
					codeaacthumb[4] =  (aa>>16)&0xFFFF;
				}
				else
				{
					codeaacthumb[4] = aa&0xFFFF ;
					codeaacthumb[5] =  (aa>>16)&0xFFFF;
				}
				//AAC
				memcpy((pGame+r_in),codeaacthumb,12);
				//exec aac
				//copy read EZflash
				*(DWORD*)&(arm9_thumb[0x134]) = rompage*0x8000 ;
				memcpy((pGame+(aa+arm9_start-arm9_copyto)),arm9_thumb,sizeof(arm9_thumb));
				*(DWORD*)(pGame+0xBF0) =  (aa+arm9_start-arm9_copyto)+ROM_AD ; //需要在Ndsloader中修改的地方
			}
			if(pArm9readrom2)
			{
				((DWORD*)arm9_thumb_readcard2)[0x84/4] = aa ;
				memcpy(pArm9readrom2,arm9_thumb_readcard2,sizeof(arm9_thumb_readcard2)-1);
			}
			
			if((saverspecial!=1))//&&(!b_gba))
			{
				//replace 0x4000204
				BYTE *p , *f;
				DWORD ss ;
				BYTE r204[] = {0x4,0x2,0,4};
				f = pGame ;
				ss = size ;
				do
				{
					p = FindMotif(f,ss,r204,0x4);
					if(!p)
						continue ;
					if(!((DWORD)p&0x3))
					{
						if(((*(DWORD*)(p-0xc) == 0xe3800080)||(*(DWORD*)(p-0xc) == 0xe3C00080))&&b_gba)
							*(DWORD*)p = 0x04000204 ;
						else
							*(DWORD*)p = 0x0E000204 ;
					}
					ss -= (p+4 - f) ;
					f = p + 4 ;
				}
				while(p);
			}
		}
	}
	DWORD jump[]=
	{//thumb  bx pc
	// dcw    0x0000
	 //arm	  ldr pc,[pc]
	 //dcd    0x jumpaddress
		0x4778,
		0xe51ff004,
		0x0200000c
	};
	if(pfRead&&pfWrite&&bSavePatch)
	{
		if(saverspecial!=1)
		{
			memcpy(pfRead,arm9_550,sizeof(arm9_550));
			*(DWORD*)(pfRead+RAM_AD) = rampage; 
			memcpy(pfWrite,arm9_47c,sizeof(arm9_47c));
			*(DWORD*)(pfWrite+RAM_AD) = rampage; 
			if(pfWrite_2)
			{
				memcpy(pfWrite_2,arm9_47c,sizeof(arm9_47c));
				*(DWORD*)(pfWrite_2+RAM_AD) = rampage; 
			}
		}
	}
	else if(pfReadThumb&&pfWriteThumb)
	{
		*(DWORD*)(arm9_47c_thumb+0x94) = rampage ;
		memcpy(pfWriteThumb,arm9_47c_thumb,sizeof(arm9_47c_thumb));
		arm9_47c_thumb[0x2a] = 0x22;
		arm9_47c_thumb[0x2C] = 0x2A;
		memcpy(pfReadThumb,arm9_47c_thumb,sizeof(arm9_47c_thumb));
	}
	else
	{
		BYTE verify ;
		BYTE th_chek[] = 
		{
			0x00 ,0xB5 ,0x81 ,0xB0 ,0x0B ,0x48 ,0x00 ,0x21 ,
			0x00 ,0xF0 ,0x26 ,0xF8 ,0x0A ,0x48 ,0x01 ,0x68 ,
			0x0A ,0x48 ,0x01 ,0x40 ,0x0A ,0x48 ,0x01 ,0x43 ,
			0x0A ,0x48 ,0x01 ,0x40 ,0x0A ,0x4A ,0x11 ,0x60 ,
			0x0A ,0x48 ,0x11 ,0x68 ,0x01 ,0x40 ,0x00 ,0x29 ,
			0xFB ,0xD0 ,0x09 ,0x48 ,0x00 ,0x68 ,0x01 ,0xB0 ,
			0x08 ,0xBC ,0x18 ,0x47
		};
		//寻找thumb指令的arm7代码中的存档
		BYTE th_erase[] =  
		{
			0x10 ,0xB5 ,0x04 ,0x1C ,0x00 ,0xF0 ,0x12 ,0xFA ,
			0x00 ,0xF0 ,0x7C ,0xF9 ,0x09 ,0x48 ,0x00 ,0x68 ,
			0x40 ,0x6A ,0x40 ,0x1C ,0x00 ,0xF0 ,0x42 ,0xFA ,
			0x20 ,0x1C ,0xD8 ,0x21 ,0x00 ,0xF0 ,0x32 ,0xF9 ,
			0x04 ,0x48 ,0x00 ,0x68 ,0x80 ,0x6B ,0x00 ,0x21 ,
			0x00 ,0xF0 ,0x06 ,0xFA ,0x10 ,0xBC ,0x08 ,0xBC
		};
		BYTE th_erase1[] =  
		{
			0x10 ,0xB5 ,0x04 ,0x1C ,0x00 ,0xF0 ,0x04 ,0xFA ,
			0x00 ,0x28 ,0x11 ,0xD0 ,0x00 ,0xF0 ,0x6C ,0xF9 ,
			0x09 ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,0x40 ,0x1C ,
			0x00 ,0xF0 ,0x42 ,0xFA ,0x20 ,0x1C ,0xD8 ,0x21 ,
			0x00 ,0xF0 ,0x22 ,0xF9 ,0x04 ,0x48 ,0x00 ,0x68 ,
			0x80 ,0x6B ,0x00 ,0x21 ,0x00 ,0xF0 ,0x06 ,0xFA
		};
		BYTE th_erase2[] = 
		{
			0x10 ,0xB5 ,0x04 ,0x1C ,0x00 ,0xF0 ,0xC0 ,0xF9 ,
			0x00 ,0xF0 ,0x2A ,0xF9 ,0x09 ,0x48 ,0x00 ,0x68 ,
			0x40 ,0x6A ,0x40 ,0x1C ,0x00 ,0xF0 ,0x06 ,0xFA ,
			0x20 ,0x1C ,0xD8 ,0x21 ,0x00 ,0xF0 ,0xE0 ,0xF8 ,
			0x04 ,0x48 ,0x00 ,0x68 ,0x80 ,0x6B ,0x00 ,0x21 ,
			0x00 ,0xF0 ,0xB6 ,0xF9 ,0x10 ,0xBC ,0x08 ,0xBC
		};
		BYTE th_verify[] = 
		{
			0x70 ,0xB5 ,0x05 ,0x1C ,0x0E ,0x1C ,0x14 ,0x1C ,
			0x00 ,0xF0 ,0xF4 ,0xF9 ,0x01 ,0x21 ,0x12 ,0x48 ,
			0xC1 ,0x60 ,0x12 ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,
			0x40 ,0x1C ,0x00 ,0x19 ,0x00 ,0xF0 ,0x22 ,0xFA ,
			0x28 ,0x1C ,0x03 ,0x21 ,0x00 ,0xF0 ,0x12 ,0xF9 ,
			0x30 ,0x1C ,0x00 ,0x21 ,0x22 ,0x1C ,0x0C ,0x4B
		};
		BYTE th_verify1[] = 
		{
			0x70 ,0xB5 ,0x05 ,0x1C ,0x0E ,0x1C ,0x14 ,0x1C ,
			0x00 ,0xF0 ,0xE4 ,0xF9 ,0x00 ,0x28 ,0x22 ,0xD0 ,
			0x01 ,0x21 ,0x12 ,0x48 ,0xC1 ,0x60 ,0x12 ,0x48 ,
			0x00 ,0x68 ,0x40 ,0x6A ,0x40 ,0x1C ,0x00 ,0x19 ,
			0x00 ,0xF0 ,0x20 ,0xFA ,0x28 ,0x1C ,0x03 ,0x21 ,
			0x00 ,0xF0 ,0x00 ,0xF9 ,0x30 ,0x1C ,0x00 ,0x21
		};
		BYTE th_verify2[] = 
		{
			0x70 ,0xB5 ,0x05 ,0x1C ,0x0E ,0x1C ,0x14 ,0x1C ,
			0x00 ,0xF0 ,0xA2 ,0xF9 ,0x01 ,0x21 ,0x12 ,0x48 ,
			0xC1 ,0x60 ,0x12 ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,
			0x40 ,0x1C ,0x00 ,0x19 ,0x00 ,0xF0 ,0xE6 ,0xF9 ,
			0x28 ,0x1C ,0x03 ,0x21 ,0x00 ,0xF0 ,0xC0 ,0xF8 ,
			0x30 ,0x1C ,0x00 ,0x21 ,0x22 ,0x1C ,0x0C ,0x4B
		};

		BYTE th_write1[] = 
		{
			0xF0 ,0xB5 ,0x81 ,0xB0 ,0x06 ,0x1C ,0x00 ,0x91 ,
			0x15 ,0x1C ,0x1B ,0x48 ,0x00 ,0x68 ,0x07 ,0x6A ,
			0x00 ,0xF0 ,0xBE ,0xF9 ,0x29 ,0xE0 ,0x78 ,0x1E ,
			0x31 ,0x1C ,0x01 ,0x40 ,0x7C ,0x1A ,0xAC ,0x42 ,
			0x00 ,0xD9 ,0x2C ,0x1C ,0x00 ,0xF0 ,0x20 ,0xF9 ,
			0x13 ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,0x40 ,0x1C
		};
		BYTE th_write1_1[] = 
		{
			0xF0 ,0xB5 ,0x81 ,0xB0 ,0x06 ,0x1C ,0x00 ,0x91 ,
			0x15 ,0x1C ,0x1C ,0x48 ,0x00 ,0x68 ,0x07 ,0x6A ,
			0x00 ,0xF0 ,0xAC ,0xF9 ,0x00 ,0x28 ,0x2A ,0xD1 ,
			0x2B ,0xE0 ,0x78 ,0x1E ,0x31 ,0x1C ,0x01 ,0x40 ,
			0x7C ,0x1A ,0xAC ,0x42 ,0x00 ,0xD9 ,0x2C ,0x1C ,
			0x00 ,0xF0 ,0x0C ,0xF9 ,0x13 ,0x48 ,0x00 ,0x68
		};
		BYTE th_write1_2[] = 
		{
			0xF0 ,0xB5 ,0x81 ,0xB0 ,0x06 ,0x1C ,0x00 ,0x91 ,
			0x15 ,0x1C ,0x1B ,0x48 ,0x00 ,0x68 ,0x07 ,0x6A ,
			0x00 ,0xF0 ,0x6C ,0xF9 ,0x29 ,0xE0 ,0x78 ,0x1E ,
			0x31 ,0x1C ,0x01 ,0x40 ,0x7C ,0x1A ,0xAC ,0x42 ,
			0x00 ,0xD9 ,0x2C ,0x1C ,0x00 ,0xF0 ,0xCE ,0xF8 ,
			0x13 ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,0x40 ,0x1C
		};

		BYTE th_write2[] = 
		{
			0xF0 ,0xB5 ,0x81 ,0xB0 ,0x06 ,0x1C ,0x00 ,0x91 ,
			0x15 ,0x1C ,0x1B ,0x48 ,0x00 ,0x68 ,0x07 ,0x6A ,
			0x00 ,0xF0 ,0x7E ,0xF9 ,0x29 ,0xE0 ,0x78 ,0x1E ,
			0x31 ,0x1C ,0x01 ,0x40 ,0x7C ,0x1A ,0xAC ,0x42 ,
			0x00 ,0xD9 ,0x2C ,0x1C ,0x00 ,0xF0 ,0xE0 ,0xF8 ,
			0x13 ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,0x40 ,0x1C
		};

		BYTE th_write2_1[] = 
		{
			0xF0 ,0xB5 ,0x81 ,0xB0 ,0x06 ,0x1C ,0x00 ,0x91 ,
			0x15 ,0x1C ,0x1C ,0x48 ,0x00 ,0x68 ,0x07 ,0x6A ,
			0x00 ,0xF0 ,0x6A ,0xF9 ,0x00 ,0x28 ,0x2A ,0xD1 ,
			0x2B ,0xE0 ,0x78 ,0x1E ,0x31 ,0x1C ,0x01 ,0x40 ,
			0x7C ,0x1A ,0xAC ,0x42 ,0x00 ,0xD9 ,0x2C ,0x1C ,
			0x00 ,0xF0 ,0xCA ,0xF8 ,0x13 ,0x48 ,0x00 ,0x68
		};
		BYTE th_write2_2[] = 
		{
			0xF0 ,0xB5 ,0x81 ,0xB0 ,0x06 ,0x1C ,0x00 ,0x91 ,
			0x15 ,0x1C ,0x1B ,0x48 ,0x00 ,0x68 ,0x07 ,0x6A ,
			0x00 ,0xF0 ,0x2C ,0xF9 ,0x29 ,0xE0 ,0x78 ,0x1E ,
			0x31 ,0x1C ,0x01 ,0x40 ,0x7C ,0x1A ,0xAC ,0x42 ,
			0x00 ,0xD9 ,0x2C ,0x1C ,0x00 ,0xF0 ,0x8E ,0xF8 ,
			0x13 ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,0x40 ,0x1C
		};
		BYTE th_read[] = 
		{
			0x70 ,0xB5 ,0x05 ,0x1C ,0x0E ,0x1C ,0x14 ,0x1C ,
			0x00 ,0xF0 ,0x42 ,0xF9 ,0x0B ,0x48 ,0x00 ,0x68 ,
			0x40 ,0x6A ,0x40 ,0x1C ,0x00 ,0x19 ,0x00 ,0xF0 ,
			0x73 ,0xF9 ,0x28 ,0x1C ,0x03 ,0x21 ,0x00 ,0xF0 ,
			0x63 ,0xF8 ,0x00 ,0x20 ,0x31 ,0x1C ,0x22 ,0x1C ,
			0x05 ,0x4B ,0x00 ,0xF0 ,0x01 ,0xF9 ,0x00 ,0x20
		};
		BYTE th_read1[] = 
		{
			0x70 ,0xB5 ,0x05 ,0x1C ,0x0E ,0x1C ,0x14 ,0x1C ,
			0x00 ,0xF0 ,0x2C ,0xF9 ,0x00 ,0x28 ,0x14 ,0xD0 ,
			0x0B ,0x48 ,0x00 ,0x68 ,0x40 ,0x6A ,0x40 ,0x1C ,
			0x00 ,0x19 ,0x00 ,0xF0 ,0x6B ,0xF9 ,0x28 ,0x1C ,
			0x03 ,0x21 ,0x00 ,0xF0 ,0x4B ,0xF8 ,0x00 ,0x20 ,
			0x31 ,0x1C ,0x22 ,0x1C ,0x05 ,0x4B ,0x00 ,0xF0
		};
		BYTE th_read2[] = 
		{
			0x70 ,0xB5 ,0x05 ,0x1C ,0x0E ,0x1C ,0x14 ,0x1C ,
			0x00 ,0xF0 ,0xF0 ,0xF8 ,0x0B ,0x48 ,0x00 ,0x68 ,
			0x40 ,0x6A ,0x40 ,0x1C ,0x00 ,0x19 ,0x00 ,0xF0 ,
			0x37 ,0xF9 ,0x28 ,0x1C ,0x03 ,0x21 ,0x00 ,0xF0 ,
			0x11 ,0xF8 ,0x00 ,0x20 ,0x31 ,0x1C ,0x22 ,0x1C ,
			0x05 ,0x4B ,0x00 ,0xF0 ,0xAF ,0xF8 ,0x00 ,0x20
		};
		BYTE *pthErase=NULL ,*pthVerify = NULL ,*pthWrit1 = NULL , *pthWrit2 = NULL ,*pthRead = NULL ,*pcheck=NULL;
		pthErase = FindMotif(pGame,size,th_erase,0x30);
		if(!pthErase)
			pthErase = FindMotif(pGame,size,th_erase1,0x30);
		if(!pthErase)
			pthErase = FindMotif(pGame,size,th_erase2,0x30);
		pthVerify = FindMotif(pGame,size,th_verify,0x30);
		verify = 1 ;
		if(!pthVerify)
		{
			pthVerify = FindMotif(pGame,size,th_verify1,0x30);
			verify = 2;
		}
		if(!pthVerify)
		{
			pthVerify = FindMotif(pGame,size,th_verify2,0x30);
			verify = 3;
		}
		pthWrit1 = FindMotif(pGame,size,th_write1,0x30);
		if(!pthWrit1)
			pthWrit1 = FindMotif(pGame,size,th_write1_1,0x30);
		if(!pthWrit1)
			pthWrit1 = FindMotif(pGame,size,th_write1_2,0x30);
		pthWrit2 = FindMotif(pGame,size,th_write2,0x30);
		if(!pthWrit2)
			pthWrit2 = FindMotif(pGame,size,th_write2_1,0x30);
		if(!pthWrit2)
			pthWrit2 = FindMotif(pGame,size,th_write2_2,0x30);
		pthRead = FindMotif(pGame,size,th_read,0x30);
		if(!pthRead)
			pthRead = FindMotif(pGame,size,th_read1,0x30);
		if(!pthRead)
			pthRead = FindMotif(pGame,size,th_read2,0x30);
		pcheck = FindMotif(pGame,size,th_chek,0x34);
		if(pcheck)
		{
			const BYTE arm9_thumext[]={0x01 ,0x48 ,0x00 ,0x68 ,0x70 ,0x47 ,0x00 ,0x00 ,0x00 ,0xF8 ,0x7F ,0x02};
			memcpy(pcheck,arm9_thumext,12);
		}
		if(pthErase&&pthWrit1&&pthRead)
		{
			int off ;
			if(verify ==1)
			{
				off = *(WORD*)(pthVerify+0x10) ;
				WORD ww = (*(WORD*)(pthVerify+0x10))&0x07C0 ;
				WORD w1 = *(WORD*)(arm7_thumb_verify_ez3+0xc) ;
				*(WORD*)(arm7_thumb_verify_ez3+0xc) = (w1&0xF83F) + ww ; 
				off = 0xFF&(*(WORD*)(pthVerify+0x12)) ;
				off = (off +3)/2*8 ;
			}
			else if(verify ==2)
			{
				off = *(WORD*)(pthVerify+0x14) ;
				WORD ww = (*(WORD*)(pthVerify+0x14))&0x07C0 ;
				WORD w1 = *(WORD*)(arm7_thumb_verify_ez3+0xc) ;
				*(WORD*)(arm7_thumb_verify_ez3+0xc) = (w1&0xF83F) + ww ; 
				off = 0xFF&(*(WORD*)(pthVerify+0x12)) ;
				off = (off + 0x5 )/2*8 ;
			}
			else if(verify ==3)
			{
				off = *(WORD*)(pthVerify+0x10) ;
				WORD ww = (*(WORD*)(pthVerify+0x10))&0x07C0 ;
				WORD w1 = *(WORD*)(arm7_thumb_verify_ez3+0xc) ;
				*(WORD*)(arm7_thumb_verify_ez3+0xc) = (w1&0xF83F) + ww ; 
				off = 0xFF&(*(WORD*)(pthVerify+0x12)) ;
				off = (off + 3)/4*16 + 4 ;
			}
			*(DWORD*)(arm7_thumb_verify_ez3+0x18) = *(DWORD*)(pthVerify+0x4+off) ;//id1
			*(DWORD*)(arm7_thumb_verify_ez3+0x1c) = *(DWORD*)(pthVerify+0x4+off+4);//id2
			memcpy(pthVerify,arm7_thumb_verify_ez3,sizeof(arm7_thumb_verify_ez3));
			//copy write
			memcpy(pthWrit1,arm7_thumb_writesaver_ez3,sizeof(arm7_thumb_writesaver_ez3));
			memcpy(pthWrit2,arm7_thumb_writesaver_ez3,sizeof(arm7_thumb_writesaver_ez3));
			//copy Read
			off = (pthRead - pthWrit2)/2 -0x18 ;
			*(WORD*)(arm7_thumb_readsaver_ez3+6) = 0x10000 - off ;
			memcpy(pthRead,arm7_thumb_readsaver_ez3,sizeof(arm7_thumb_readsaver_ez3));
		}
	}
	//拷贝最初的nds 执行代码
	fixCRC(pGame);

BYTE *nonheader = new BYTE[0x200];
	memcpy(nonheader,pGame,0x200);
	memset(nonheader,0,0x20);
	memset(nonheader+0xC0,0,0x140);
	if(b_ids)
		memcpy(pGame+0xc00,nonheader,0x200);
	else
	{
		memcpy(pGame+0xc00,pGame,0x200);
	}
	memcpy(pGame+0x200,pmdy+0x160,lenth-0x160);
	//memcpy(pGame+0xa0,pGame+0xC00,12);

	delete nonheader ;
	if(pCmp) delete pCmp ;
	if(pmdy) delete pmdy ;
	return TRUE ;
}


DWORD CRomManager::SaverPatch(BYTE **buf,
							  DWORD *length,
							  EZCARTTYPE cartType,
							  UINT saverOffset,
							  SAVERTYPE *dwSaverType,
							  DWORD dwReserved)
{
	BYTE *find, *findread, *findwrite, *findidentify, *finderase, *finderasesec,*findrampage;
	DWORD rvalue = 0;

	*dwSaverType = UNKNOW ;
	rvalue = 0;

	find = FindMotif(*buf, *length, (BYTE*)"SRAM_", 5);
	if(find)
	{
		*dwSaverType = SRAM_TYPE ; //表示存档类型为sram
		rvalue = 32768;
	}
	find = FindMotif(*buf, *length, (BYTE*)"EEPROM_V", 8);
	if(find)
	{	
		*dwSaverType = EEPROM_TYPE ;
		rvalue = 8192;
		if((char)find[8]=='1' && (char)find[9]=='2' &&(((char)find[10] =='4')||((char)find[10] =='6')))
		{
			findread = FindMotif(*buf, *length, e12x_read, e12x_read_LEN);
			findwrite = FindMotif(*buf, *length, e124_write, e12x_write_LEN);
			if(!findwrite)
				findwrite = FindMotif(*buf, *length, e124_write2, 0x20);
				
			findidentify = FindMotif(*buf, *length, e12x_identify, e12x_identify_LEN);

			if(findread && findwrite)
			{
				if(findidentify)
					memcpy(findidentify+0x36, e12x_newidentify, e12x_newidentify_LEN);
				memcpy(findread, e12x_newread, e12x_newread_LEN);
				memcpy(findwrite, e12x_newwrite, e12x_newwrite_LEN);
			}
		}
		else if((char)find[8]=='1' && (char)find[9]=='2')
		{
			findread = FindMotif(*buf, *length, e12x_read, e12x_read_LEN);
			findwrite = FindMotif(*buf, *length, e12x_write, e12x_write_LEN);
			findidentify = FindMotif(*buf, *length, e12x_identify, e12x_identify_LEN);
			if(findread && findwrite)
			{
				if(findidentify)
					memcpy(findidentify+0x36, e12x_newidentify, e12x_newidentify_LEN);
				memcpy(findread, e12x_newread, e12x_newread_LEN);
				memcpy(findwrite, e12x_newwrite, e12x_newwrite_LEN);
			}
		}
		else if((char)find[8]=='1' && (char)find[9]=='1')
		{
			findread = FindMotif(*buf, *length, e11x_read, e11x_read_LEN);
			findwrite = FindMotif(*buf, *length, e11x_write, e11x_write_LEN);
			if(findread && findwrite)
			{
				BYTE *pTemp = new BYTE[256] ;
				int find2 = (int)(findread - *buf);
				int find3 = (int)(findwrite - *buf);

				BYTE st[10], pr[188];
				memcpy(st,e11x_newread,e11x_newread_LEN);
				memcpy(pr,e11x_code,e11x_code_LEN);

				pr[184] = find2 + 0x21;
				pr[186] = find2 >> 16;
				memcpy((*buf)+find3,e11x_newwrite,e11x_newwrite_LEN);
				memset(pTemp,0xFF,256);
				findrampage=FindMotif(*buf, *length, pTemp,256);
				if(!findrampage)
				{
					memset(pTemp,0,256);
					findrampage=FindMotif(*buf, *length, pTemp,256);
				}
				if(findrampage)
				{
					DWORD endf;
					endf=findrampage-*buf;
					endf=(endf +0x10)&0xFFFFF0;
					if(((*buf)[endf-1] != 0xff) && ((*buf)[endf-1] != 0xcd))
						pr[185] = (find2 + 0x1f) >> 8;
					else
						pr[185] = find2 >> 8;

					st[4] = ((char)(endf)&0xFF)+1;
					st[5] = (char)(endf >> 8)&0xFF;
					st[6] = (char)(endf >> 16)&0xFF;

					memcpy((*buf)+find2, st, 10);
					memcpy((*buf)+endf, pr, 188);

				}
				delete pTemp ;
				/*
				int find2 = (int)(findread - *buf);
				int find3 = (int)(findwrite - *buf);

				BYTE st[10], pr[188];
				memcpy(st,e11x_newread,e11x_newread_LEN);
				memcpy(pr,e11x_code,e11x_code_LEN);

				pr[184] = find2 + 0x21;
				pr[186] = find2 >> 16;

				memcpy((*buf)+find3,e11x_newwrite,e11x_newwrite_LEN);

				DWORD endf = *length - 1;
				endf += 256 - (endf % 256);

				BYTE* oldbuf = *buf;
				*buf=new BYTE[endf+188];
				memcpy(*buf,oldbuf,*length);
				*length = endf + 188;
				delete[] oldbuf;

				if(((*buf)[endf-1] != 0xff) && ((*buf)[endf-1] != 0xcd))
					pr[185] = (find2 + 0x1f) >> 8;
				else
					pr[185] = find2 >> 8;

				st[5] = (char)(endf >> 8)&0xFF;
				st[6] = (char)(endf >> 16)&0xFF;

				memcpy((*buf)+find2, st, 10);
				memcpy((*buf)+endf, pr, 188);
				*/
			}
		}
	}//eeprom 结束
/*	if( cartType  == EZ2Cart)
	{
		find = FindMotif(*buf, *length, (BYTE*)"FLASH", 5);
		if(find) 
		{
			*dwSaverType = FLASH_TYPE ;
			rvalue = 65536;
		}
		find = FindMotif(*buf, *length, (BYTE*)"FLASH1M_", 8);
		if(find)
		{
			*dwSaverType = FLASH_TYPE ;
			rvalue = 65536*2;
		}
		return rvalue ;
	}
*/
	find = FindMotif(*buf, *length, (BYTE*)"FLASH_V", 7);
	if(find)
	{
		*dwSaverType = FLASH_TYPE ;
		rvalue = 65536;

		if((char)find[7]=='1' && (char)find[8]=='2' && (char)find[9]>'1')
		{
			findread = FindMotif(*buf, *length, f12x_read, f12x_read_LEN);
			findwrite = FindMotif(*buf, *length, f12x_write, f12x_write_LEN);
			findidentify = FindMotif(*buf, *length, f12x_identify, f12x_identify_LEN);
			finderase = FindMotif(*buf, *length, f12x_erase, f12x_erase_LEN);
			finderasesec = FindMotif(*buf, *length, f12x_erasesec, f12x_erasesec_LEN);

			if(findread && findwrite)
			{
				if(findidentify)
					memcpy(findidentify, f12x_MNidentify, f12x_newidentify_LEN);
				if(finderase)
					memcpy(finderase, f12x_return0, f12x_return0_LEN);
				if(finderasesec)
					memcpy(finderasesec, f12x_return0, f12x_return0_LEN);
				memcpy(findread, f12x_newread, f12x_newread_LEN);
				memcpy(findwrite, f12x_newwrite, f12x_newwrite_LEN);
			}
		}
		if((char)find[7]=='1' && (char)find[8]=='2' && (char)find[9]<'2')
		{
			findwrite = FindMotif(*buf, *length, f121_write, f121_write_LEN);
			findidentify = FindMotif(*buf, *length, f121_identify, f121_identify_LEN);
			finderase = FindMotif(*buf, *length, f121_erase, f121_erase_LEN);
			finderasesec = FindMotif(*buf, *length, f121_erasesec, f121_erasesec_LEN);
			if(findwrite&&findread)
			{
				if(findidentify)
					memcpy(findidentify, f121_newidentify, f121_newidentify_LEN);
				if(finderase)
					memcpy(finderase, f121_return0, f121_return0_LEN);
				if(finderasesec)
					memcpy(finderasesec, f121_return0, f121_return0_LEN);
				memcpy(findwrite, f121_newwrite, f121_newwrite_LEN);
			}
		}
	}

	find = FindMotif(*buf, *length, (BYTE*)"FLASH512_V", 10);
	if(find)
	{
		*dwSaverType = FLASH_TYPE ;
		rvalue = 65536;
		if((char)find[10]=='1'&& (char)find[11]=='3')
		{
			findidentify = FindMotif(*buf, *length, f512_130_identify, f512_130_identify_LEN);
			findread = FindMotif(*buf, *length, f512_130_read, f512_130_read_LEN);
			findwrite = FindMotif(*buf, *length, f512_130_write, f512_130_write_LEN);
			finderase = FindMotif(*buf, *length, f512_130_erase, f512_130_erase_LEN);
			finderasesec = FindMotif(*buf, *length, f512_130_erasesec, f512_130_erasesec_LEN);

			if(findread && findwrite)
			{
				if(findidentify)
					memcpy(findidentify, f512_130_MNidentify, f512_130_newidentify_LEN);

				if(finderase)
					memcpy(finderase, f512_130_return0, f512_130_return0_LEN);

				if(finderasesec)
					memcpy(finderasesec, f512_130_return0, f512_130_return0_LEN);

				memcpy(findread, f512_130_newread, f512_130_newread_LEN);
				memcpy(findwrite, f512_130_newwrite, f512_130_newwrite_LEN);
			}
		}
	}
	find = FindMotif(*buf, *length, (BYTE*)"FLASH1M_V", 9);
	BYTE  *find1M1,*find1M2,*find1M3,*find1M4,*find1M5,*find1M6;

	if(find)
	{
		*dwSaverType = FLASH_TYPE ;
		rvalue = 65536*2;
		
		if((char)find[9]=='1'&&(char)find[10]=='0'&&(char)find[11]=='3')
		{//special 口袋妖怪
			find1M1 = FindMotif(*buf, *length, f1M_102_orig1, f1M_102_orig1_LEN);
			find1M2 = FindMotif(*buf, *length, f1M_102_orig2, f1M_102_orig2_LEN);
			find1M3 = FindMotif(*buf, *length, f1M_102_orig3, f1M_102_orig3_LEN);
			if(!find1M3)
				find1M3 = FindMotif(*buf, *length, f1M_102_orig3_1, f1M_102_orig3_LEN);
			find1M4 = FindMotif(*buf, *length, f1M_102_orig4, f1M_102_orig4_LEN);
			find1M5 = FindMotif(*buf, *length, f1M_102_orig5, f1M_102_orig5_LEN);
			find1M6 = FindMotif(*buf, *length, f1M_102_orig6, f1M_102_orig6_LEN);
			finderase = FindMotif(*buf, *length, f512_130_erase, f512_130_erase_LEN);
			finderasesec = FindMotif(*buf, *length, f512_130_erasesec, f512_130_erasesec_LEN);

			findidentify = FindMotif(*buf,*length,flash1M103_identify,flash1M103_identify_LEN);
			
			if(find1M4 && find1M5&&find1M6)
			{
				if( cartType  == EZ1OLDWHITE)
				{//
					f1M_102_repl4[0x24] = 0x80 ;
					f1M_102_repl4[0x25] = 0 ;
					f1M_102_repl5[0x2c] = 0x9b;
					f1M_102_repl5[0x2d] = 0;
					f1M_102_repl6[0x30] = 0xa4;
					f1M_102_repl6[0x31] = 0;
				}
				else
				{
					f1M_102_repl4[0x24] = 0x00 ;
					f1M_102_repl4[0x25] = 0x01 ;
					f1M_102_repl5[0x2c] = 0x1b;
					f1M_102_repl5[0x2d] = 0x01;
					f1M_102_repl6[0x30] = 0x24;
					f1M_102_repl6[0x31] = 0x01;
				}
				f1M_102_repl4[0x26] = saverOffset ;
				f1M_102_repl5[0x2e] = saverOffset ;
				f1M_102_repl6[0x32] = saverOffset ;
				if(find1M1)
					memcpy(find1M1, f1M_102_repl1, f1M_102_repl1_LEN);
				if(find1M2)
					memcpy(find1M2, f1M_102_repl2, f1M_102_repl2_LEN);
				if(find1M3)
					memcpy(find1M3, f1M_102_repl3, f1M_102_repl3_LEN);
				memcpy(find1M4, f1M_102_repl4, f1M_102_repl4_LEN);
				memcpy(find1M5, f1M_102_repl5, f1M_102_repl5_LEN);
				memcpy(find1M6, f1M_102_repl6, f1M_102_repl6_LEN);

				if(finderase)
					memcpy(finderase, f512_130_return0, f512_130_return0_LEN);

				if(finderasesec)
					memcpy(finderasesec, f512_130_return0, f512_130_return0_LEN);

				if(findidentify)
					memcpy(findidentify,flash1M103_new_identify,flash1M103_new_identify_LEN);

			}
		}
		else if((char)find[9]=='1'&&(char)find[10]=='0'&&(char)find[11]=='2')
		{
			do{
				findidentify = FindMotif(*buf,*length,flash1M103_identify,flash1M103_identify_LEN);
				findrampage = FindMotif(*buf,*length,flash1M103_Setrampage,flash1M103_Setrampage_LEN);
				finderase = FindMotif(*buf,*length,flash1M103_Erase,flash1M103_Erase_LEN);
				find1M5 = FindMotif(*buf,*length,flash1M103_Program,flash1M103_Program_LEN);
				findwrite = FindMotif(*buf,*length,flash1M103_Write,flash1M103_Write_LEN);
				if( cartType  == EZ1OLDWHITE)
				{//
					flash1M103_new_Erase[0x24] = 0x80 ;
					flash1M103_new_Erase[0x25] = 0 ;
					flash1M103_new_Write[0x30] = 0xa4;
					flash1M103_new_Write[0x31] = 0;
				}
				else
				{
					flash1M103_new_Erase[0x24] = 0x00 ;
					flash1M103_new_Erase[0x25] = 0x01 ;
					flash1M103_new_Write[0x30] = 0x24;
					flash1M103_new_Write[0x31] = 0x01;
				}
				flash1M103_new_Erase[0x26] = saverOffset ;
				flash1M103_new_Write[0x32] = saverOffset ;

				if(finderase&&findrampage)
				{
					if(findidentify)
						memcpy(findidentify,flash1M103_new_identify,flash1M103_new_identify_LEN);
					if(findrampage)
						memcpy(findrampage,flash1M103_new_Setrampage,flash1M103_new_Setrampage_LEN);
					if(finderase)
						memcpy(finderase,flash1M103_new_Erase,flash1M103_new_Erase_LEN);
					if(find1M5)
						memcpy(find1M5,flash1M103_new_Program,flash1M103_new_Program_LEN);
					if(findwrite)
						memcpy(findwrite,flash1M103_new_Write,flash1M103_new_Write_LEN);
				}
			}while(findidentify&&findrampage&&finderase&&findwrite);
		}
		
	}
	return rvalue ;
}

void CRomManager::Modify1MSaverRom(BYTE **buf, DWORD *length,UINT saverOffset)
{
	BYTE *find ,*find1M4,*find1M5,*find1M6;
	find = FindMotif(*buf, *length, (BYTE*)"FLASH1M_V", 9);
	if(find)
	{
		if((char)find[9]=='1'&&(char)find[10]=='0'&&(char)find[11]=='3')
		{
			find1M4 = FindMotif(*buf, *length, f1M_102_repl4, f1M_102_orig4_LEN);
			find1M5 = FindMotif(*buf, *length, f1M_102_repl5, f1M_102_orig5_LEN);
			find1M6 = FindMotif(*buf, *length, f1M_102_repl6, f1M_102_orig6_LEN);
			if(find1M4 && find1M5&&find1M6)
			{
				find1M4[0x26] = saverOffset ;
				find1M5[0x2e] = saverOffset ;
				find1M6[0x32] = saverOffset ;
			}
		}
		else if((char)find[9]=='1'&&(char)find[10]=='0'&&(char)find[11]=='2')
		{
			find1M4 = FindMotif(*buf,*length,flash1M103_new_Erase,flash1M103_new_Erase_LEN);
			find1M6 = FindMotif(*buf,*length,flash1M103_new_Write,flash1M103_new_Write_LEN);
			if(find1M4 &&find1M6)
			{
				find1M4[0x26] = saverOffset ;
				find1M6[0x32] = saverOffset ;
			}
		}
	}
}

DWORD CRomManager::SpecialRomPatch(BYTE **buf, DWORD *length,EZCARTTYPE cartType,DWORD dwReserved)
{
	char name[16] ;
	memset(name,0,16);
	//here 处理特别的游戏
	memcpy(name,&(*buf)[0xa0],12);
	if(!strcmp(_T("SONICPINBALL"),name))
	{
		if(*((WORD*)&(*buf)[0x6050c]) == 0x42b0 )
			*((WORD*)&(*buf)[0x6050c]) = 0x4280 ;
		if(*((WORD*)&(*buf)[0x60524]) == 0x42b0 )
			*((WORD*)&(*buf)[0x60524]) = 0x4280 ;
		if(*((WORD*)&(*buf)[0x607c2]) == 0x28ff )
			*((WORD*)&(*buf)[0x607c2]) = 0x4280 ;
		if(*((DWORD*)&(*buf)[0xde264]) == 0x0b42b0ef )
			*((DWORD*)&(*buf)[0xde264]) = 0x0b4280ef ;
		if(*((DWORD*)&(*buf)[0xde458]) == 0xf828ff09 )
			*((DWORD*)&(*buf)[0xde458]) =  0xf8428009 ;
	}
	else if((!strcmp(_T("BOKUTAI"),name))&&(cartType == EZ2Cart))
	{
		*(*buf+0x1C336C) = 0xE4;
		*(*buf+0x1C336D) = 0xF0;
		*(*buf+0x1C336E) = 0xEE;
			
		*(*buf+0xEEF0C4+0x20) = 0xA8;
		*(*buf+0xEEF0C5+0x20) =	0x00;
		*(*buf+0xEEF0C6+0x20) =	0x9F;
		*(*buf+0xEEF0C7+0x20) =	0xE5;
		*(*buf+0xEEF0C8+0x20) =	0x00;	
		*(*buf+0xEEF0C9+0x20) =	0xE0;
		*(*buf+0xEEF0CA+0x20) =	0xA0;
		*(*buf+0xEEF0CB+0x20) =	0xE1;
		*(*buf+0xEEF0CC+0x20) =	0xA8;
		*(*buf+0xEEF0CD+0x20) =	0x00;
		*(*buf+0xEEF0CE+0x20) =	0x9F;
		*(*buf+0xEEF0CF+0x20) =	0xE5;
		*(*buf+0xEEF0D0+0x20) =	0x10;
		*(*buf+0xEEF0D1+0x20) =	0xFF;
		*(*buf+0xEEF0D2+0x20) =	0x2F;
		*(*buf+0xEEF0D3+0x20) = 0xE1;
		
		*(*buf+0xEEF174+0x20) = 0xD0;
		*(*buf+0xEEF175+0x20) = 0x00;
		*(*buf+0xEEF176+0x20) = 0x00;
		*(*buf+0xEEF177+0x20) = 0x08;
		*(*buf+0xEEF178+0x20) = 0x00;
		*(*buf+0xEEF179+0x20) = 0x00;
		*(*buf+0xEEF17A+0x20) = 0x00;
		*(*buf+0xEEF17B+0x20) = 0x00;
		*(*buf+0xEEF17C+0x20) = 0xE9;
		*(*buf+0xEEF17D+0x20) = 0x33;
		*(*buf+0xEEF17E+0x20) = 0x1C;
		*(*buf+0xEEF17F+0x20) = 0x08;
	}
//ez1卡带bug 必须改正
	memset(name,0,16);
	memcpy(name,&(*buf)[0xAC],4);
	if((!strcmp(_T("GMBA"),name))||(!strcmp(_T("PCEA"),name))||
		(!strcmp(_T("FCA"),name))||(!strcmp(_T("PNES"),name)))
	{
		if(*(DWORD*)(*buf+0xDCC) == 0x02000000)
			*(DWORD*)(*buf+0xDCC) = 0x02000004 ;
	}
	return 0 ;
}

BOOL CRomManager::HeaderValid(BYTE *buf)
{
/*
	if(StandardHeader)
	{
		//return false for Nintendo logo invalid
		for(i=0;i<156;i++)
		{
			if(buf[i+4]!=Nintendo_logo[i]) return(false);
		}

		//return false for complement check failed
		sum = 0;
		for(i=160;i<=188;i++) sum += buf[i];
		sum += 0x19;
		if(buf[189]!=(BYTE)(256 - (sum % 256))) return(false);
		//return false for first instruction error
		if(*(BYTE *)&buf[3] != 0xea) return(false);
	}
	else
	{
		//return false for first instruction error
		if(*(BYTE *)&buf[3] != 0xea) return(false);
	}
*/
	//return false for first instruction error
	if(buf[3] != 0xea) return(false);
	//游戏文件的第三个字结是否是0xEA;
	//return false for data in address 0xB2 is not 0x96
	if(buf[178]!=0x96) return(false);
	return(true);
}

void CRomManager::FillComplementCheck(BYTE *buf)
{
	BYTE sum = 0;
	for(WORD i=0xa0; i<=0xbc; i++)
		sum += buf[i];
	sum += 0x19;
	sum = 0x100 - sum;
	buf[0xbd] = sum;
}

void CRomManager::InflateROM(BYTE **buf, DWORD *length)
{
	if(((*length)%32768)!=0)
	{
		BYTE* oldbuf = *buf;
		UINT newleng = (UINT)ceil(((double)*length)/32768)*32768 ;
		*buf=new BYTE[newleng];
		memset(*buf,0xff,newleng);
		memcpy(*buf,oldbuf,*length);
		*length =newleng ;
		delete[] oldbuf;
	}
}

DWORD CRomManager::GetSaverTypeAndSize(BYTE **buf,DWORD *length,SAVERTYPE *type)
{
	BYTE * find = NULL ;
	*type = UNKNOW ;
	DWORD rvalue = 0;

	find = FindMotif(*buf, *length, (BYTE*)"SRAM_", 5);
	if(find)
	{
		*type = SRAM_TYPE ; //表示存档类型为sram
		rvalue = 32768;
	}
	find = FindMotif(*buf, *length, (BYTE*)"EEPROM_V", 8);
	if(find)
	{
		*type = EEPROM_TYPE ; //表示存档类型为sram
		rvalue = 8192 ;
	}
	find = FindMotif(*buf, *length, (BYTE*)"FLASH_V", 7);
	if(find) 
	{
		*type = FLASH_TYPE ;
		rvalue = 65536;
	}
	find = FindMotif(*buf, *length, (BYTE*)"FLASH512_V", 9);
	if(find) 
	{
		*type = FLASH_TYPE ;
		rvalue = 65536;
	}
	find = FindMotif(*buf, *length, (BYTE*)"FLASH1M_", 8);
	if(find)
	{
		*type = FLASH_TYPE ;
		rvalue = 65536*2;
	}

	char name[16] ;
	memset(name,0,16);
	//here 处理特别的游戏
	memcpy(name,&(*buf)[0xa0],12);
	memset(name,0,16);
	memcpy(name,&(*buf)[0xAC],4);
	if((!strcmp(_T("GMBA"),name))||(!strcmp(_T("PCEA"),name))||
		(!strcmp(_T("FCA"),name))||(!strcmp(_T("PNES"),name)))
	{
		*type = SRAM_TYPE ; //表示存档类型为sram
		rvalue = 32768;
	}

	return rvalue ;
}

void CRomManager::GetPCECharacter(int Index,
								  BOOL &f50CPUClock,
								  BOOL &fUSRom,
								  BOOL &fCPUHACKDISABLE,
								  BOOL &fFollowMem,
								  DWORD &dwFollowSprite)
{
	f50CPUClock=m_flagPCE_50CPUClock[Index] ;//b
	fUSRom=m_flagPCE_USRom[Index]; //bit1
	fCPUHACKDISABLE=m_flagPCE_CPUHackDisable[Index];
	fFollowMem=m_flagPCE_FollowMem[Index];	 
	dwFollowSprite=m_dwPCE_FollowSprite[Index];
}

void CRomManager::GetNESCharacter(int iIndex ,//note max is 64
					  BOOL &fFFUhackEn,
					  BOOL &fCPUhackDis,
					  BOOL &fUsePALTimeing,
					  BOOL &fFollowMem,
					  DWORD &dwFollowSprite)
{
	fFFUhackEn=m_flagNES_CPUHackDisable[iIndex];
	fCPUhackDis=m_flagNES_FFUHackEnable[iIndex];
	fUsePALTimeing=m_flagNES_UsePALTimeing[iIndex];
	fFollowMem=m_flagNES_FollowMem[iIndex];
	dwFollowSprite=m_dwNES_FollowSprite[iIndex];
}

BOOL CRomManager::RemoveIntro(BYTE *pData, DWORD *pdwLen)
{
	DWORD addr = *((DWORD *)pData);
	addr = 0x8 + (addr & 0x00ffffff)*4;
	BYTE chars[8]={0x12,0x00,0xa0,0xe3,0x00,0xf0,0x29,0xe1};
	DWORD where =0 ;
	BYTE *pFind = FindMotif(pData,*pdwLen,chars,8);
	//If addr > 0x8000 then we regard it as intro added
	if(addr > 0x8000)
	{
		if(pFind)
		{
			where = (pFind - pData - 8)>>2;
			if(where >0x2000)
				return FALSE ;
			//Set new good address
			*(DWORD *)pData = 0xea000000 + where ;

			//Remove the intro
			*pdwLen = addr;
			return TRUE;
		}
	}
	return FALSE ;

}
